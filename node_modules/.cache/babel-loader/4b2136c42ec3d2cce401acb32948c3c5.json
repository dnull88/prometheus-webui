{"ast":null,"code":"/**\n *\n * THIS FILE WAS COPIED INTO PROMETHEUS FROM GRAFANA'S VENDORED FORK OF FLOT\n * (LIVING AT https://github.com/grafana/grafana/tree/master/public/vendor/flot),\n * WHICH CONTAINS FIXES FOR DISPLAYING NULL VALUES IN STACKED GRAPHS. THE ORIGINAL\n * FLOT CODE WAS LICENSED UNDER THE MIT LICENSE AS STATED BELOW. ADDITIONAL\n * CHANGES HAVE BEEN CONTRIBUTED TO THE GRAFANA FORK UNDER AN APACHE 2 LICENSE, SEE\n * https://github.com/grafana/grafana/blob/master/license.\n *\n */\n\n/* eslint-disable prefer-spread */\n\n/* eslint-disable no-loop-func */\n\n/* eslint-disable @typescript-eslint/no-this-alias */\n\n/* eslint-disable no-redeclare */\n\n/* eslint-disable no-useless-escape */\n\n/* eslint-disable prefer-const */\n\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/* eslint-disable eqeqeq */\n\n/* eslint-disable no-var */\n\n/* Javascript plotting library for jQuery, version 0.8.3.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\n*/\n// first an inline dependency, jquery.colorhelpers.js, we inline it here\n// for convenience\n\n/* Plugin for jQuery for working with colors.\n *\n * Version 1.1.\n *\n * Inspiration from jQuery color animation plugin by John Resig.\n *\n * Released under the MIT license by Ole Laursen, October 2009.\n *\n * Examples:\n *\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\n *   console.log(c.r, c.g, c.b, c.a);\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\n *\n * Note that .scale() and .add() return the same modified object\n * instead of making a new one.\n *\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\n * produce a color rather than just crashing.\n */\n(function ($) {\n  $.color = {};\n\n  $.color.make = function (r, g, b, a) {\n    var o = {};\n    o.r = r || 0;\n    o.g = g || 0;\n    o.b = b || 0;\n    o.a = a != null ? a : 1;\n\n    o.add = function (c, d) {\n      for (var i = 0; i < c.length; ++i) {\n        o[c.charAt(i)] += d;\n      }\n\n      return o.normalize();\n    };\n\n    o.scale = function (c, f) {\n      for (var i = 0; i < c.length; ++i) {\n        o[c.charAt(i)] *= f;\n      }\n\n      return o.normalize();\n    };\n\n    o.toString = function () {\n      if (o.a >= 1) {\n        return 'rgb(' + [o.r, o.g, o.b].join(',') + ')';\n      } else {\n        return 'rgba(' + [o.r, o.g, o.b, o.a].join(',') + ')';\n      }\n    };\n\n    o.normalize = function () {\n      function clamp(min, value, max) {\n        return value < min ? min : value > max ? max : value;\n      }\n\n      o.r = clamp(0, parseInt(o.r), 255);\n      o.g = clamp(0, parseInt(o.g), 255);\n      o.b = clamp(0, parseInt(o.b), 255);\n      o.a = clamp(0, o.a, 1);\n      return o;\n    };\n\n    o.clone = function () {\n      return $.color.make(o.r, o.b, o.g, o.a);\n    };\n\n    return o.normalize();\n  };\n\n  $.color.extract = function (elem, css) {\n    var c;\n\n    do {\n      c = elem.css(css).toLowerCase();\n      if (c != '' && c != 'transparent') break;\n      elem = elem.parent();\n    } while (elem.length && !$.nodeName(elem.get(0), 'body'));\n\n    if (c == 'rgba(0, 0, 0, 0)') c = 'transparent';\n    return $.color.parse(c);\n  };\n\n  $.color.parse = function (str) {\n    var res,\n        m = $.color.make;\n    if (res = /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str)) return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10));\n    if (res = /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str)) return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10), parseFloat(res[4]));\n    if (res = /rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(str)) return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55);\n    if (res = /rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str)) return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55, parseFloat(res[4]));\n    if (res = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str)) return m(parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16));\n    if (res = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str)) return m(parseInt(res[1] + res[1], 16), parseInt(res[2] + res[2], 16), parseInt(res[3] + res[3], 16));\n    var name = $.trim(str).toLowerCase();\n    if (name == 'transparent') return m(255, 255, 255, 0);else {\n      res = lookupColors[name] || [0, 0, 0];\n      return m(res[0], res[1], res[2]);\n    }\n  };\n\n  var lookupColors = {\n    aqua: [0, 255, 255],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    black: [0, 0, 0],\n    blue: [0, 0, 255],\n    brown: [165, 42, 42],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgrey: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkviolet: [148, 0, 211],\n    fuchsia: [255, 0, 255],\n    gold: [255, 215, 0],\n    green: [0, 128, 0],\n    indigo: [75, 0, 130],\n    khaki: [240, 230, 140],\n    lightblue: [173, 216, 230],\n    lightcyan: [224, 255, 255],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    navy: [0, 0, 128],\n    olive: [128, 128, 0],\n    orange: [255, 165, 0],\n    pink: [255, 192, 203],\n    purple: [128, 0, 128],\n    violet: [128, 0, 128],\n    red: [255, 0, 0],\n    silver: [192, 192, 192],\n    white: [255, 255, 255],\n    yellow: [255, 255, 0]\n  };\n})(window.jQuery); // the actual Flot code\n\n\n(function ($) {\n  // Cache the prototype hasOwnProperty for faster access\n  var hasOwnProperty = Object.prototype.hasOwnProperty; // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM\n  // operation produces the same effect as detach, i.e. removing the element\n  // without touching its jQuery data.\n  // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.\n\n  if (!$.fn.detach) {\n    $.fn.detach = function () {\n      return this.each(function () {\n        if (this.parentNode) {\n          this.parentNode.removeChild(this);\n        }\n      });\n    };\n  } ///////////////////////////////////////////////////////////////////////////\n  // The Canvas object is a wrapper around an HTML5 <canvas> tag.\n  //\n  // @constructor\n  // @param {string} cls List of classes to apply to the canvas.\n  // @param {element} container Element onto which to append the canvas.\n  //\n  // Requiring a container is a little iffy, but unfortunately canvas\n  // operations don't work unless the canvas is attached to the DOM.\n\n\n  function Canvas(cls, container) {\n    var element = container.children('.' + cls)[0];\n\n    if (element == null) {\n      element = document.createElement('canvas');\n      element.className = cls;\n      $(element).css({\n        direction: 'ltr',\n        position: 'absolute',\n        left: 0,\n        top: 0\n      }).appendTo(container); // If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas\n\n      if (!element.getContext) {\n        if (window.G_vmlCanvasManager) {\n          element = window.G_vmlCanvasManager.initElement(element);\n        } else {\n          throw new Error(\"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\");\n        }\n      }\n    }\n\n    this.element = element;\n    var context = this.context = element.getContext('2d'); // Determine the screen's ratio of physical to device-independent\n    // pixels.  This is the ratio between the canvas width that the browser\n    // advertises and the number of pixels actually present in that space.\n    // The iPhone 4, for example, has a device-independent width of 320px,\n    // but its screen is actually 640px wide.  It therefore has a pixel\n    // ratio of 2, while most normal devices have a ratio of 1.\n\n    var devicePixelRatio = window.devicePixelRatio || 1,\n        backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n    this.pixelRatio = devicePixelRatio / backingStoreRatio; // Size the canvas to match the internal dimensions of its container\n\n    this.resize(container.width(), container.height()); // Collection of HTML div layers for text overlaid onto the canvas\n\n    this.textContainer = null;\n    this.text = {}; // Cache of text fragments and metrics, so we can avoid expensively\n    // re-calculating them when the plot is re-rendered in a loop.\n\n    this._textCache = {};\n    this._textSizeCache = window.flotTextSizeCache = window.flotTextSizeCache || {};\n  } // Resizes the canvas to the given dimensions.\n  //\n  // @param {number} width New width of the canvas, in pixels.\n  // @param {number} width New height of the canvas, in pixels.\n\n\n  Canvas.prototype.resize = function (width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error('Invalid dimensions for plot, width = ' + width + ', height = ' + height);\n    }\n\n    var element = this.element,\n        context = this.context,\n        pixelRatio = this.pixelRatio; // Resize the canvas, increasing its density based on the display's\n    // pixel ratio; basically giving it more pixels without increasing the\n    // size of its element, to take advantage of the fact that retina\n    // displays have that many more pixels in the same advertised space.\n    // Resizing should reset the state (excanvas seems to be buggy though)\n\n    if (this.width != width) {\n      element.width = width * pixelRatio;\n      element.style.width = width + 'px';\n      this.width = width;\n    }\n\n    if (this.height != height) {\n      element.height = height * pixelRatio;\n      element.style.height = height + 'px';\n      this.height = height;\n    } // Save the context, so we can reset in case we get replotted.  The\n    // restore ensure that we're really back at the initial state, and\n    // should be safe even if we haven't saved the initial state yet.\n\n\n    context.restore();\n    context.save(); // Scale the coordinate space to match the display density; so even though we\n    // may have twice as many pixels, we still want lines and other drawing to\n    // appear at the same size; the extra pixels will just make them crisper.\n\n    context.scale(pixelRatio, pixelRatio);\n  }; // Clears the entire canvas area, not including any overlaid HTML text\n\n\n  Canvas.prototype.clear = function () {\n    this.context.clearRect(0, 0, this.width, this.height);\n  }; // Finishes rendering the canvas, including managing the text overlay.\n\n\n  Canvas.prototype.render = function () {\n    var cache = this._textCache; // For each text layer, add elements marked as active that haven't\n    // already been rendered, and remove those that are no longer active.\n\n    for (var layerKey in cache) {\n      if (hasOwnProperty.call(cache, layerKey)) {\n        var layer = this.getTextLayer(layerKey),\n            layerCache = cache[layerKey];\n        layer.hide();\n\n        for (var styleKey in layerCache) {\n          if (hasOwnProperty.call(layerCache, styleKey)) {\n            var styleCache = layerCache[styleKey];\n\n            for (var key in styleCache) {\n              if (hasOwnProperty.call(styleCache, key)) {\n                var positions = styleCache[key].positions;\n\n                for (var i = 0, position; position = positions[i]; i++) {\n                  if (position.active) {\n                    if (!position.rendered) {\n                      layer.append(position.element);\n                      position.rendered = true;\n                    }\n                  } else {\n                    positions.splice(i--, 1);\n\n                    if (position.rendered) {\n                      position.element.detach();\n                    }\n                  }\n                }\n\n                if (positions.length == 0) {\n                  delete styleCache[key];\n                }\n              }\n            }\n          }\n        }\n\n        layer.show();\n      }\n    }\n  }; // Creates (if necessary) and returns the text overlay container.\n  //\n  // @param {string} classes String of space-separated CSS classes used to\n  //     uniquely identify the text layer.\n  // @return {object} The jQuery-wrapped text-layer div.\n\n\n  Canvas.prototype.getTextLayer = function (classes) {\n    var layer = this.text[classes]; // Create the text layer if it doesn't exist\n\n    if (layer == null) {\n      // Create the text layer container, if it doesn't exist\n      if (this.textContainer == null) {\n        this.textContainer = $(\"<div class='flot-text flot-temp-elem'></div>\").css({\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          bottom: 0,\n          right: 0,\n          'font-size': 'smaller',\n          color: '#545454'\n        }).insertAfter(this.element);\n      }\n\n      layer = this.text[classes] = $('<div></div>').addClass(classes).css({\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0\n      }).appendTo(this.textContainer);\n    }\n\n    return layer;\n  }; // Creates (if necessary) and returns a text info object.\n  //\n  // The object looks like this:\n  //\n  // {\n  //     width: Width of the text's wrapper div.\n  //     height: Height of the text's wrapper div.\n  //     element: The jQuery-wrapped HTML div containing the text.\n  //     positions: Array of positions at which this text is drawn.\n  // }\n  //\n  // The positions array contains objects that look like this:\n  //\n  // {\n  //     active: Flag indicating whether the text should be visible.\n  //     rendered: Flag indicating whether the text is currently visible.\n  //     element: The jQuery-wrapped HTML div containing the text.\n  //     x: X coordinate at which to draw the text.\n  //     y: Y coordinate at which to draw the text.\n  // }\n  //\n  // Each position after the first receives a clone of the original element.\n  //\n  // The idea is that that the width, height, and general 'identity' of the\n  // text is constant no matter where it is placed; the placements are a\n  // secondary property.\n  //\n  // Canvas maintains a cache of recently-used text info objects; getTextInfo\n  // either returns the cached element or creates a new entry.\n  //\n  // @param {string} layer A string of space-separated CSS classes uniquely\n  //     identifying the layer containing this text.\n  // @param {string} text Text string to retrieve info for.\n  // @param {(string|object)=} font Either a string of space-separated CSS\n  //     classes or a font-spec object, defining the text's font and style.\n  // @param {number=} angle Angle at which to rotate the text, in degrees.\n  //     Angle is currently unused, it will be implemented in the future.\n  // @param {number=} width Maximum width of the text before it wraps.\n  // @return {object} a text info object.\n\n\n  Canvas.prototype.getTextInfo = function (layer, text, font, angle, width) {\n    var textStyle, layerCache, styleCache, info; // Cast the value to a string, in case we were given a number or such\n\n    text = '' + text; // If the font is a font-spec object, generate a CSS font definition\n\n    if (typeof font === 'object') {\n      textStyle = font.style + ' ' + font.variant + ' ' + font.weight + ' ' + font.size + 'px/' + font.lineHeight + 'px ' + font.family;\n    } else {\n      textStyle = font;\n    } // Retrieve (or create) the cache for the text's layer and styles\n\n\n    layerCache = this._textCache[layer];\n\n    if (layerCache == null) {\n      layerCache = this._textCache[layer] = {};\n    }\n\n    styleCache = layerCache[textStyle];\n\n    if (styleCache == null) {\n      styleCache = layerCache[textStyle] = {};\n    }\n\n    info = styleCache[text]; // If we can't find a matching element in our cache, create a new one\n\n    if (info == null) {\n      var element = $('<div></div>').html(text).css({\n        position: 'absolute',\n        'max-width': width,\n        top: -9999\n      }).appendTo(this.getTextLayer(layer));\n\n      if (typeof font === 'object') {\n        element.css({\n          font: textStyle,\n          color: font.color\n        });\n      } else if (typeof font === 'string') {\n        element.addClass(font);\n      }\n\n      info = styleCache[text] = {\n        element: element,\n        positions: []\n      };\n      var size = this._textSizeCache[text];\n\n      if (size) {\n        info.width = size.width;\n        info.height = size.height;\n      } else {\n        info.width = element.outerWidth(true);\n        info.height = element.outerHeight(true);\n        this._textSizeCache[text] = {\n          width: info.width,\n          height: info.height\n        };\n      }\n\n      element.detach();\n    }\n\n    return info;\n  }; // Adds a text string to the canvas text overlay.\n  //\n  // The text isn't drawn immediately; it is marked as rendering, which will\n  // result in its addition to the canvas on the next render pass.\n  //\n  // @param {string} layer A string of space-separated CSS classes uniquely\n  //     identifying the layer containing this text.\n  // @param {number} x X coordinate at which to draw the text.\n  // @param {number} y Y coordinate at which to draw the text.\n  // @param {string} text Text string to draw.\n  // @param {(string|object)=} font Either a string of space-separated CSS\n  //     classes or a font-spec object, defining the text's font and style.\n  // @param {number=} angle Angle at which to rotate the text, in degrees.\n  //     Angle is currently unused, it will be implemented in the future.\n  // @param {number=} width Maximum width of the text before it wraps.\n  // @param {string=} halign Horizontal alignment of the text; either \"left\",\n  //     \"center\" or \"right\".\n  // @param {string=} valign Vertical alignment of the text; either \"top\",\n  //     \"middle\" or \"bottom\".\n\n\n  Canvas.prototype.addText = function (layer, x, y, text, font, angle, width, halign, valign) {\n    var info = this.getTextInfo(layer, text, font, angle, width),\n        positions = info.positions; // Tweak the div's position to match the text's alignment\n\n    if (halign == 'center') {\n      x -= info.width / 2;\n    } else if (halign == 'right') {\n      x -= info.width;\n    }\n\n    if (valign == 'middle') {\n      y -= info.height / 2;\n    } else if (valign == 'bottom') {\n      y -= info.height;\n    } // Determine whether this text already exists at this position.\n    // If so, mark it for inclusion in the next render pass.\n\n\n    for (var i = 0, position; position = positions[i]; i++) {\n      if (position.x == x && position.y == y) {\n        position.active = true;\n        return;\n      }\n    } // If the text doesn't exist at this position, create a new entry\n    // For the very first position we'll re-use the original element,\n    // while for subsequent ones we'll clone it.\n\n\n    position = {\n      active: true,\n      rendered: false,\n      element: positions.length ? info.element.clone() : info.element,\n      x: x,\n      y: y\n    };\n    positions.push(position); // Move the element to its final position within the container\n\n    position.element.css({\n      top: Math.round(y),\n      left: Math.round(x),\n      'text-align': halign // In case the text wraps\n\n    });\n  }; // Removes one or more text strings from the canvas text overlay.\n  //\n  // If no parameters are given, all text within the layer is removed.\n  //\n  // Note that the text is not immediately removed; it is simply marked as\n  // inactive, which will result in its removal on the next render pass.\n  // This avoids the performance penalty for 'clear and redraw' behavior,\n  // where we potentially get rid of all text on a layer, but will likely\n  // add back most or all of it later, as when redrawing axes, for example.\n  //\n  // @param {string} layer A string of space-separated CSS classes uniquely\n  //     identifying the layer containing this text.\n  // @param {number=} x X coordinate of the text.\n  // @param {number=} y Y coordinate of the text.\n  // @param {string=} text Text string to remove.\n  // @param {(string|object)=} font Either a string of space-separated CSS\n  //     classes or a font-spec object, defining the text's font and style.\n  // @param {number=} angle Angle at which the text is rotated, in degrees.\n  //     Angle is currently unused, it will be implemented in the future.\n\n\n  Canvas.prototype.removeText = function (layer, x, y, text, font, angle) {\n    if (text == null) {\n      var layerCache = this._textCache[layer];\n\n      if (layerCache != null) {\n        for (var styleKey in layerCache) {\n          if (hasOwnProperty.call(layerCache, styleKey)) {\n            var styleCache = layerCache[styleKey];\n\n            for (var key in styleCache) {\n              if (hasOwnProperty.call(styleCache, key)) {\n                var positions = styleCache[key].positions;\n\n                for (var i = 0, position; position = positions[i]; i++) {\n                  position.active = false;\n                }\n              }\n            }\n          }\n        }\n      }\n    } else {\n      var positions = this.getTextInfo(layer, text, font, angle).positions;\n\n      for (var i = 0, position; position = positions[i]; i++) {\n        if (position.x == x && position.y == y) {\n          position.active = false;\n        }\n      }\n    }\n  }; ///////////////////////////////////////////////////////////////////////////\n  // The top-level container for the entire plot.\n\n\n  function Plot(placeholder, data_, options_, plugins) {\n    // data is on the form:\n    //   [ series1, series2 ... ]\n    // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\n    // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\n    var series = [],\n        options = {\n      // the color theme used for graphs\n      colors: ['#edc240', '#afd8f8', '#cb4b4b', '#4da74d', '#9440ed'],\n      legend: {\n        show: true,\n        noColumns: 1,\n        // number of colums in legend table\n        labelFormatter: null,\n        // fn: string -> string\n        labelBoxBorderColor: '#ccc',\n        // border color for the little label boxes\n        container: null,\n        // container (as jQuery object) to put legend in, null means default on top of graph\n        position: 'ne',\n        // position of default legend container within plot\n        margin: 5,\n        // distance from grid edge to default legend container within plot\n        backgroundColor: null,\n        // null means auto-detect\n        backgroundOpacity: 0.85,\n        // set to 0 to avoid background\n        sorted: null // default to no legend sorting\n\n      },\n      xaxis: {\n        show: null,\n        // null = auto-detect, true = always, false = never\n        position: 'bottom',\n        // or \"top\"\n        mode: null,\n        // null or \"time\"\n        font: null,\n        // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: \"italic\", weight: \"bold\", family: \"sans-serif\", variant: \"small-caps\" }\n        color: null,\n        // base color, labels, ticks\n        tickColor: null,\n        // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\n        transform: null,\n        // null or f: number -> number to transform axis\n        inverseTransform: null,\n        // if transform is set, this should be the inverse function\n        min: null,\n        // min. value to show, null means set automatically\n        max: null,\n        // max. value to show, null means set automatically\n        autoscaleMargin: null,\n        // margin in % to add if auto-setting min/max\n        ticks: null,\n        // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\n        tickFormatter: null,\n        // fn: number -> string\n        labelWidth: null,\n        // size of tick labels in pixels\n        labelHeight: null,\n        reserveSpace: null,\n        // whether to reserve space even if axis isn't shown\n        tickLength: null,\n        // size in pixels of ticks, or \"full\" for whole line\n        alignTicksWithAxis: null,\n        // axis number or null for no sync\n        tickDecimals: null,\n        // no. of decimals, null means auto\n        tickSize: null,\n        // number or [number, \"unit\"]\n        minTickSize: null // number or [number, \"unit\"]\n\n      },\n      yaxis: {\n        autoscaleMargin: 0.02,\n        position: 'left' // or \"right\"\n\n      },\n      xaxes: [],\n      yaxes: [],\n      series: {\n        points: {\n          show: false,\n          radius: 3,\n          lineWidth: 2,\n          // in pixels\n          fill: true,\n          fillColor: '#ffffff',\n          symbol: 'circle' // or callback\n\n        },\n        lines: {\n          // we don't put in show: false so we can see\n          // whether lines were actively disabled\n          lineWidth: 2,\n          // in pixels\n          fill: false,\n          fillColor: null,\n          steps: false // Omit 'zero', so we can later default its value to\n          // match that of the 'fill' option.\n\n        },\n        bars: {\n          show: false,\n          lineWidth: 2,\n          // in pixels\n          barWidth: 1,\n          // in units of the x axis\n          fill: true,\n          fillColor: null,\n          align: 'left',\n          // \"left\", \"right\", or \"center\"\n          horizontal: false,\n          zero: true\n        },\n        shadowSize: 3,\n        highlightColor: null\n      },\n      grid: {\n        show: true,\n        aboveData: false,\n        color: '#545454',\n        // primary color used for outline and labels\n        backgroundColor: null,\n        // null for transparent, else color\n        borderColor: null,\n        // set if different from the grid color\n        tickColor: null,\n        // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\n        margin: 0,\n        // distance from the canvas edge to the grid\n        labelMargin: 5,\n        // in pixels\n        eventSectionHeight: 0,\n        // space for event section\n        axisMargin: 8,\n        // in pixels\n        borderWidth: 2,\n        // in pixels\n        minBorderMargin: null,\n        // in pixels, null means taken from points radius\n        markings: null,\n        // array of ranges or fn: axes -> array of ranges\n        markingsColor: '#f4f4f4',\n        markingsLineWidth: 2,\n        // interactive stuff\n        clickable: false,\n        hoverable: false,\n        autoHighlight: true,\n        // highlight in case mouse is near\n        mouseActiveRadius: 10 // how far the mouse can be away to activate an item\n\n      },\n      interaction: {\n        redrawOverlayInterval: 1000 / 60 // time between updates, -1 means in same flow\n\n      },\n      hooks: {}\n    },\n        surface = null,\n        // the canvas for the plot itself\n    overlay = null,\n        // canvas for interactive stuff on top of plot\n    eventHolder = null,\n        // jQuery object that events should be bound to\n    ctx = null,\n        octx = null,\n        xaxes = [],\n        yaxes = [],\n        plotOffset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n        plotWidth = 0,\n        plotHeight = 0,\n        hooks = {\n      processOptions: [],\n      processRawData: [],\n      processDatapoints: [],\n      processOffset: [],\n      processRange: [],\n      drawBackground: [],\n      drawSeries: [],\n      draw: [],\n      bindEvents: [],\n      drawOverlay: [],\n      shutdown: []\n    },\n        plot = this; // public functions\n\n    plot.setData = setData;\n    plot.setupGrid = setupGrid;\n    plot.draw = draw;\n\n    plot.getPlaceholder = function () {\n      return placeholder;\n    };\n\n    plot.getCanvas = function () {\n      return surface.element;\n    };\n\n    plot.getPlotOffset = function () {\n      return plotOffset;\n    };\n\n    plot.width = function () {\n      return plotWidth;\n    };\n\n    plot.height = function () {\n      return plotHeight;\n    };\n\n    plot.offset = function () {\n      var o = eventHolder.offset();\n      o.left += plotOffset.left;\n      o.top += plotOffset.top;\n      return o;\n    };\n\n    plot.getData = function () {\n      return series;\n    };\n\n    plot.getAxes = function () {\n      var res = {};\n      $.each(xaxes.concat(yaxes), function (_, axis) {\n        if (axis) res[axis.direction + (axis.n != 1 ? axis.n : '') + 'axis'] = axis;\n      });\n      return res;\n    };\n\n    plot.getXAxes = function () {\n      return xaxes;\n    };\n\n    plot.getYAxes = function () {\n      return yaxes;\n    };\n\n    plot.c2p = canvasToAxisCoords;\n    plot.p2c = axisToCanvasCoords;\n\n    plot.getOptions = function () {\n      return options;\n    };\n\n    plot.highlight = highlight;\n    plot.unhighlight = unhighlight;\n    plot.triggerRedrawOverlay = triggerRedrawOverlay;\n\n    plot.pointOffset = function (point) {\n      return {\n        left: parseInt(xaxes[axisNumber(point, 'x') - 1].p2c(+point.x) + plotOffset.left, 10),\n        top: parseInt(yaxes[axisNumber(point, 'y') - 1].p2c(+point.y) + plotOffset.top, 10)\n      };\n    };\n\n    plot.shutdown = shutdown;\n\n    plot.destroy = function () {\n      shutdown();\n      placeholder.removeData('plot').empty();\n      series = [];\n      options = null;\n      surface = null;\n      overlay = null;\n      eventHolder = null;\n      ctx = null;\n      octx = null;\n      xaxes = [];\n      yaxes = [];\n      hooks = null;\n      highlights = [];\n      plot = null;\n    };\n\n    plot.resize = function () {\n      var width = placeholder.width(),\n          height = placeholder.height();\n      surface.resize(width, height);\n      overlay.resize(width, height);\n    }; // public attributes\n\n\n    plot.hooks = hooks; // initialize\n\n    initPlugins(plot);\n    parseOptions(options_);\n    setupCanvases();\n    setData(data_);\n    setupGrid();\n    draw();\n    bindEvents();\n\n    function executeHooks(hook, args) {\n      args = [plot].concat(args);\n\n      for (var i = 0; i < hook.length; ++i) {\n        hook[i].apply(this, args);\n      }\n    }\n\n    function initPlugins() {\n      // References to key classes, allowing plugins to modify them\n      var classes = {\n        Canvas: Canvas\n      };\n\n      for (var i = 0; i < plugins.length; ++i) {\n        var p = plugins[i];\n        p.init(plot, classes);\n        if (p.options) $.extend(true, options, p.options);\n      }\n    }\n\n    function parseOptions(opts) {\n      $.extend(true, options, opts); // $.extend merges arrays, rather than replacing them.  When less\n      // colors are provided than the size of the default palette, we\n      // end up with those colors plus the remaining defaults, which is\n      // not expected behavior; avoid it by replacing them here.\n\n      if (opts && opts.colors) {\n        options.colors = opts.colors;\n      }\n\n      if (options.xaxis.color == null) options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n      if (options.yaxis.color == null) options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n      if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility\n        options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n      if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility\n        options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n      if (options.grid.borderColor == null) options.grid.borderColor = options.grid.color;\n      if (options.grid.tickColor == null) options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString(); // Fill in defaults for axis options, including any unspecified\n      // font-spec fields, if a font-spec was provided.\n      // If no x/y axis options were provided, create one of each anyway,\n      // since the rest of the code assumes that they exist.\n\n      var i,\n          axisOptions,\n          axisCount,\n          fontSize = placeholder.css('font-size'),\n          fontSizeDefault = fontSize ? +fontSize.replace('px', '') : 13,\n          fontDefaults = {\n        style: placeholder.css('font-style'),\n        size: Math.round(0.8 * fontSizeDefault),\n        variant: placeholder.css('font-variant'),\n        weight: placeholder.css('font-weight'),\n        family: placeholder.css('font-family')\n      };\n      axisCount = options.xaxes.length || 1;\n\n      for (i = 0; i < axisCount; ++i) {\n        axisOptions = options.xaxes[i];\n\n        if (axisOptions && !axisOptions.tickColor) {\n          axisOptions.tickColor = axisOptions.color;\n        }\n\n        axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\n        options.xaxes[i] = axisOptions;\n\n        if (axisOptions.font) {\n          axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n\n          if (!axisOptions.font.color) {\n            axisOptions.font.color = axisOptions.color;\n          }\n\n          if (!axisOptions.font.lineHeight) {\n            axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n          }\n        }\n      }\n\n      axisCount = options.yaxes.length || 1;\n\n      for (i = 0; i < axisCount; ++i) {\n        axisOptions = options.yaxes[i];\n\n        if (axisOptions && !axisOptions.tickColor) {\n          axisOptions.tickColor = axisOptions.color;\n        }\n\n        axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\n        options.yaxes[i] = axisOptions;\n\n        if (axisOptions.font) {\n          axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n\n          if (!axisOptions.font.color) {\n            axisOptions.font.color = axisOptions.color;\n          }\n\n          if (!axisOptions.font.lineHeight) {\n            axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n          }\n        }\n      } // backwards compatibility, to be removed in future\n\n\n      if (options.xaxis.noTicks && options.xaxis.ticks == null) options.xaxis.ticks = options.xaxis.noTicks;\n      if (options.yaxis.noTicks && options.yaxis.ticks == null) options.yaxis.ticks = options.yaxis.noTicks;\n\n      if (options.x2axis) {\n        options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\n        options.xaxes[1].position = 'top'; // Override the inherit to allow the axis to auto-scale\n\n        if (options.x2axis.min == null) {\n          options.xaxes[1].min = null;\n        }\n\n        if (options.x2axis.max == null) {\n          options.xaxes[1].max = null;\n        }\n      }\n\n      if (options.y2axis) {\n        options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\n        options.yaxes[1].position = 'right'; // Override the inherit to allow the axis to auto-scale\n\n        if (options.y2axis.min == null) {\n          options.yaxes[1].min = null;\n        }\n\n        if (options.y2axis.max == null) {\n          options.yaxes[1].max = null;\n        }\n      }\n\n      if (options.grid.coloredAreas) options.grid.markings = options.grid.coloredAreas;\n      if (options.grid.coloredAreasColor) options.grid.markingsColor = options.grid.coloredAreasColor;\n      if (options.lines) $.extend(true, options.series.lines, options.lines);\n      if (options.points) $.extend(true, options.series.points, options.points);\n      if (options.bars) $.extend(true, options.series.bars, options.bars);\n      if (options.shadowSize != null) options.series.shadowSize = options.shadowSize;\n      if (options.highlightColor != null) options.series.highlightColor = options.highlightColor; // save options on axes for future reference\n\n      for (i = 0; i < options.xaxes.length; ++i) {\n        getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n      }\n\n      for (i = 0; i < options.yaxes.length; ++i) {\n        getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n      } // add hooks from options\n\n\n      for (var n in hooks) {\n        if (options.hooks[n] && options.hooks[n].length) hooks[n] = hooks[n].concat(options.hooks[n]);\n      }\n\n      executeHooks(hooks.processOptions, [options]);\n    }\n\n    function setData(d) {\n      series = parseData(d);\n      fillInSeriesOptions();\n      processData();\n    }\n\n    function parseData(d) {\n      var res = [];\n\n      for (var i = 0; i < d.length; ++i) {\n        var s = $.extend(true, {}, options.series);\n\n        if (d[i].data != null) {\n          s.data = d[i].data; // move the data instead of deep-copy\n\n          delete d[i].data;\n          $.extend(true, s, d[i]);\n          d[i].data = s.data;\n        } else s.data = d[i];\n\n        res.push(s);\n      }\n\n      return res;\n    }\n\n    function axisNumber(obj, coord) {\n      var a = obj[coord + 'axis'];\n      if (typeof a == 'object') // if we got a real axis, extract number\n        a = a.n;\n      if (typeof a != 'number') a = 1; // default to first axis\n\n      return a;\n    }\n\n    function allAxes() {\n      // return flat array without annoying null entries\n      return $.grep(xaxes.concat(yaxes), function (a) {\n        return a;\n      });\n    }\n\n    function canvasToAxisCoords(pos) {\n      // return an object with x/y corresponding to all used axes\n      var res = {},\n          i,\n          axis;\n\n      for (i = 0; i < xaxes.length; ++i) {\n        axis = xaxes[i];\n        if (axis) res['x' + axis.n] = axis.c2p(pos.left);\n      }\n\n      for (i = 0; i < yaxes.length; ++i) {\n        axis = yaxes[i];\n        if (axis) res['y' + axis.n] = axis.c2p(pos.top);\n      }\n\n      if (res.x1 !== undefined) res.x = res.x1;\n      if (res.y1 !== undefined) res.y = res.y1;\n      return res;\n    }\n\n    function axisToCanvasCoords(pos) {\n      // get canvas coords from the first pair of x/y found in pos\n      var res = {},\n          i,\n          axis,\n          key;\n\n      for (i = 0; i < xaxes.length; ++i) {\n        axis = xaxes[i];\n\n        if (axis && axis.used) {\n          key = 'x' + axis.n;\n          if (pos[key] == null && axis.n == 1) key = 'x';\n\n          if (pos[key] != null) {\n            res.left = axis.p2c(pos[key]);\n            break;\n          }\n        }\n      }\n\n      for (i = 0; i < yaxes.length; ++i) {\n        axis = yaxes[i];\n\n        if (axis && axis.used) {\n          key = 'y' + axis.n;\n          if (pos[key] == null && axis.n == 1) key = 'y';\n\n          if (pos[key] != null) {\n            res.top = axis.p2c(pos[key]);\n            break;\n          }\n        }\n      }\n\n      return res;\n    }\n\n    function getOrCreateAxis(axes, number) {\n      if (!axes[number - 1]) axes[number - 1] = {\n        n: number,\n        // save the number for future reference\n        direction: axes == xaxes ? 'x' : 'y',\n        options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)\n      };\n      return axes[number - 1];\n    }\n\n    function fillInSeriesOptions() {\n      var neededColors = series.length,\n          maxIndex = -1,\n          i; // Subtract the number of series that already have fixed colors or\n      // color indexes from the number that we still need to generate.\n\n      for (i = 0; i < series.length; ++i) {\n        var sc = series[i].color;\n\n        if (sc != null) {\n          neededColors--;\n\n          if (typeof sc == 'number' && sc > maxIndex) {\n            maxIndex = sc;\n          }\n        }\n      } // If any of the series have fixed color indexes, then we need to\n      // generate at least as many colors as the highest index.\n\n\n      if (neededColors <= maxIndex) {\n        neededColors = maxIndex + 1;\n      } // Generate all the colors, using first the option colors and then\n      // variations on those colors once they're exhausted.\n\n\n      var c,\n          colors = [],\n          colorPool = options.colors,\n          colorPoolSize = colorPool.length,\n          variation = 0;\n\n      for (i = 0; i < neededColors; i++) {\n        c = $.color.parse(colorPool[i % colorPoolSize] || '#666'); // Each time we exhaust the colors in the pool we adjust\n        // a scaling factor used to produce more variations on\n        // those colors. The factor alternates negative/positive\n        // to produce lighter/darker colors.\n        // Reset the variation after every few cycles, or else\n        // it will end up producing only white or black colors.\n\n        if (i % colorPoolSize == 0 && i) {\n          if (variation >= 0) {\n            if (variation < 0.5) {\n              variation = -variation - 0.2;\n            } else variation = 0;\n          } else variation = -variation;\n        }\n\n        colors[i] = c.scale('rgb', 1 + variation);\n      } // Finalize the series options, filling in their colors\n\n\n      var colori = 0,\n          s;\n\n      for (i = 0; i < series.length; ++i) {\n        s = series[i]; // assign colors\n\n        if (s.color == null) {\n          s.color = colors[colori].toString();\n          ++colori;\n        } else if (typeof s.color == 'number') s.color = colors[s.color].toString(); // turn on lines automatically in case nothing is set\n\n\n        if (s.lines.show == null) {\n          var v,\n              show = true;\n\n          for (v in s) {\n            if (s[v] && s[v].show) {\n              show = false;\n              break;\n            }\n          }\n\n          if (show) s.lines.show = true;\n        } // If nothing was provided for lines.zero, default it to match\n        // lines.fill, since areas by default should extend to zero.\n\n\n        if (s.lines.zero == null) {\n          s.lines.zero = !!s.lines.fill;\n        } // setup axes\n\n\n        s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, 'x'));\n        s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, 'y'));\n      }\n    }\n\n    function processData() {\n      var topSentry = Number.POSITIVE_INFINITY,\n          bottomSentry = Number.NEGATIVE_INFINITY,\n          fakeInfinity = Number.MAX_VALUE,\n          i,\n          j,\n          k,\n          m,\n          s,\n          points,\n          ps,\n          val,\n          f,\n          p,\n          data,\n          format;\n\n      function updateAxis(axis, min, max) {\n        if (min < axis.datamin && min != -fakeInfinity) axis.datamin = min;\n        if (max > axis.datamax && max != fakeInfinity) axis.datamax = max;\n      }\n\n      $.each(allAxes(), function (_, axis) {\n        // init axis\n        axis.datamin = topSentry;\n        axis.datamax = bottomSentry;\n        axis.used = false;\n      });\n\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n        s.datapoints = {\n          points: []\n        };\n        executeHooks(hooks.processRawData, [s, s.data, s.datapoints]);\n      } // first pass: clean and copy data\n\n\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n        data = s.data;\n        format = s.datapoints.format;\n\n        if (!format) {\n          format = []; // find out how to copy\n\n          format.push({\n            x: true,\n            number: true,\n            required: true\n          });\n          format.push({\n            y: true,\n            number: true,\n            required: true\n          });\n\n          if (s.stack || s.bars.show || s.lines.show && s.lines.fill) {\n            var autoscale = !!(s.bars.show && s.bars.zero || s.lines.show && s.lines.zero);\n            format.push({\n              y: true,\n              number: true,\n              required: false,\n              defaultValue: 0,\n              autoscale: autoscale\n            });\n\n            if (s.bars.horizontal) {\n              delete format[format.length - 1].y;\n              format[format.length - 1].x = true;\n            }\n          }\n\n          s.datapoints.format = format;\n        }\n\n        if (s.datapoints.pointsize != null) continue; // already filled in\n\n        s.datapoints.pointsize = format.length;\n        ps = s.datapoints.pointsize;\n        points = s.datapoints.points;\n        var insertSteps = s.lines.show && s.lines.steps;\n        s.xaxis.used = s.yaxis.used = true;\n\n        for (j = k = 0; j < data.length; ++j, k += ps) {\n          p = data[j];\n          var nullify = p == null;\n\n          if (!nullify) {\n            for (m = 0; m < ps; ++m) {\n              val = p[m];\n              f = format[m];\n\n              if (f) {\n                if (f.number && val != null) {\n                  val = +val; // convert to number\n\n                  if (isNaN(val)) val = null;else if (val == Infinity) val = fakeInfinity;else if (val == -Infinity) val = -fakeInfinity;\n                }\n\n                if (val == null) {\n                  if (f.required) nullify = true;\n                  if (f.defaultValue != null) val = f.defaultValue;\n                }\n              }\n\n              points[k + m] = val;\n            }\n          }\n\n          if (nullify) {\n            for (m = 0; m < ps; ++m) {\n              val = points[k + m];\n\n              if (val != null) {\n                f = format[m]; // extract min/max info\n\n                if (f.autoscale !== false) {\n                  if (f.x) {\n                    updateAxis(s.xaxis, val, val);\n                  }\n\n                  if (f.y) {\n                    updateAxis(s.yaxis, val, val);\n                  }\n                }\n              }\n\n              points[k + m] = null;\n            }\n          }\n\n          if (insertSteps && k > 0 && (!nullify || points[k - ps] != null)) {\n            // copy the point to make room for a middle point\n            for (m = 0; m < ps; ++m) {\n              points[k + ps + m] = points[k + m];\n            } // middle point has same y\n\n\n            points[k + 1] = points[k - ps + 1] || 0; // if series has null values, let's give the last !null value a nice step\n\n            if (nullify) points[k] = p[0]; // we've added a point, better reflect that\n\n            k += ps;\n          }\n        }\n      } // give the hooks a chance to run\n\n\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n        points = s.datapoints.points;\n        ps = s.datapoints.pointsize; // grafana\n\n        if (s.transform === 'negative-Y') {\n          for (j = 0; j < points.length; j += ps) {\n            if (points[j] == null) continue;\n            val = points[j + 1];\n            points[j + 1] = -val;\n          }\n        }\n\n        executeHooks(hooks.processDatapoints, [s, s.datapoints]);\n      } // second pass: find datamax/datamin for auto-scaling\n\n\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n        points = s.datapoints.points;\n        ps = s.datapoints.pointsize;\n        format = s.datapoints.format;\n        var xmin = topSentry,\n            ymin = topSentry,\n            xmax = bottomSentry,\n            ymax = bottomSentry;\n\n        for (j = 0; j < points.length; j += ps) {\n          if (points[j] == null) continue;\n\n          for (m = 0; m < ps; ++m) {\n            val = points[j + m];\n            f = format[m];\n            if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity) continue;\n\n            if (f.x) {\n              if (val < xmin) xmin = val;\n              if (val > xmax) xmax = val;\n            }\n\n            if (f.y) {\n              if (val < ymin) ymin = val;\n              if (val > ymax) ymax = val;\n            }\n          }\n        }\n\n        if (s.bars.show) {\n          // make sure we got room for the bar on the dancing floor\n          var delta;\n\n          switch (s.bars.align) {\n            case 'left':\n              delta = 0;\n              break;\n\n            case 'right':\n              delta = -s.bars.barWidth;\n              break;\n\n            default:\n              delta = -s.bars.barWidth / 2;\n          }\n\n          if (s.bars.horizontal) {\n            ymin += delta;\n            ymax += delta + s.bars.barWidth;\n          } else {\n            xmin += delta;\n            xmax += delta + s.bars.barWidth;\n          }\n        }\n\n        updateAxis(s.xaxis, xmin, xmax);\n        updateAxis(s.yaxis, ymin, ymax);\n      }\n\n      $.each(allAxes(), function (_, axis) {\n        if (axis.datamin == topSentry) axis.datamin = null;\n        if (axis.datamax == bottomSentry) axis.datamax = null;\n      });\n    }\n\n    function setupCanvases() {\n      // Make sure the placeholder is clear of everything except canvases\n      // from a previous plot in this container that we'll try to re-use.\n      placeholder.find('.flot-temp-elem').remove();\n      if (placeholder.css('position') == 'static') placeholder.css('position', 'relative'); // for positioning labels and overlay\n\n      surface = new Canvas('flot-base', placeholder);\n      overlay = new Canvas('flot-overlay', placeholder); // overlay canvas for interactive features\n\n      ctx = surface.context;\n      octx = overlay.context; // define which element we're listening for events on\n\n      eventHolder = $(overlay.element).unbind(); // If we're re-using a plot object, shut down the old one\n\n      var existing = placeholder.data('plot');\n\n      if (existing) {\n        existing.shutdown();\n        overlay.clear();\n      } // save in case we get replotted\n\n\n      placeholder.data('plot', plot);\n    }\n\n    function bindEvents() {\n      // bind events\n      if (options.grid.hoverable) {\n        eventHolder.mousemove(onMouseMove); // Use bind, rather than .mouseleave, because we officially\n        // still support jQuery 1.2.6, which doesn't define a shortcut\n        // for mouseenter or mouseleave.  This was a bug/oversight that\n        // was fixed somewhere around 1.3.x.  We can return to using\n        // .mouseleave when we drop support for 1.2.6.\n\n        eventHolder.bind('mouseleave', onMouseLeave);\n      }\n\n      if (options.grid.clickable) eventHolder.click(onClick);\n      executeHooks(hooks.bindEvents, [eventHolder]);\n    }\n\n    function shutdown() {\n      if (redrawTimeout) clearTimeout(redrawTimeout);\n      eventHolder.unbind('mousemove', onMouseMove);\n      eventHolder.unbind('mouseleave', onMouseLeave);\n      eventHolder.unbind('click', onClick);\n      executeHooks(hooks.shutdown, [eventHolder]);\n    }\n\n    function setTransformationHelpers(axis) {\n      // set helper functions on the axis, assumes plot area\n      // has been computed already\n      function identity(x) {\n        return x;\n      }\n\n      var s,\n          m,\n          t = axis.options.transform || identity,\n          it = axis.options.inverseTransform; // precompute how much the axis is scaling a point\n      // in canvas space\n\n      if (axis.direction == 'x') {\n        s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n        m = Math.min(t(axis.max), t(axis.min));\n      } else {\n        s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n        s = -s;\n        m = Math.max(t(axis.max), t(axis.min));\n      } // data point to canvas coordinate\n\n\n      if (t == identity) // slight optimization\n        axis.p2c = function (p) {\n          return (p - m) * s;\n        };else axis.p2c = function (p) {\n        return (t(p) - m) * s;\n      }; // canvas coordinate to data point\n\n      if (!it) axis.c2p = function (c) {\n        return m + c / s;\n      };else axis.c2p = function (c) {\n        return it(m + c / s);\n      };\n    }\n\n    function measureTickLabels(axis) {\n      var opts = axis.options,\n          ticks = axis.ticks || [],\n          labelWidth = opts.labelWidth || 0,\n          labelHeight = opts.labelHeight || 0,\n          maxWidth = labelWidth || (axis.direction == 'x' ? Math.floor(surface.width / (ticks.length || 1)) : null),\n          legacyStyles = axis.direction + 'Axis ' + axis.direction + axis.n + 'Axis',\n          layer = 'flot-' + axis.direction + '-axis flot-' + axis.direction + axis.n + '-axis ' + legacyStyles,\n          font = opts.font || 'flot-tick-label tickLabel';\n\n      for (var i = 0; i < ticks.length; ++i) {\n        var t = ticks[i];\n        if (!t.label) continue;\n        var info = surface.getTextInfo(layer, t.label, font, null, maxWidth); /// Grafana fix, add +1 to label width\n\n        labelWidth = Math.max(labelWidth, info.width + 1);\n        labelHeight = Math.max(labelHeight, info.height);\n      }\n\n      axis.labelWidth = opts.labelWidth || labelWidth;\n      axis.labelHeight = opts.labelHeight || labelHeight;\n    }\n\n    function allocateAxisBoxFirstPhase(axis) {\n      // find the bounding box of the axis by looking at label\n      // widths/heights and ticks, make room by diminishing the\n      // plotOffset; this first phase only looks at one\n      // dimension per axis, the other dimension depends on the\n      // other axes so will have to wait\n      var lw = axis.labelWidth,\n          lh = axis.labelHeight,\n          pos = axis.options.position,\n          isXAxis = axis.direction === 'x',\n          tickLength = axis.options.tickLength,\n          axisMargin = options.grid.axisMargin,\n          padding = options.grid.labelMargin,\n          eventSectionPadding = options.grid.eventSectionHeight,\n          innermost = true,\n          outermost = true,\n          first = true,\n          found = false; // Determine the axis's position in its direction and on its side\n\n      $.each(isXAxis ? xaxes : yaxes, function (i, a) {\n        if (a && (a.show || a.reserveSpace)) {\n          if (a === axis) {\n            found = true;\n          } else if (a.options.position === pos) {\n            if (found) {\n              outermost = false;\n            } else {\n              innermost = false;\n            }\n          }\n\n          if (!found) {\n            first = false;\n          }\n        }\n      }); // The outermost axis on each side has no margin\n\n      if (outermost) {\n        axisMargin = 0;\n      } // The ticks for the first axis in each direction stretch across\n\n\n      if (tickLength == null) {\n        tickLength = first ? 'full' : 5;\n      }\n\n      if (!isNaN(+tickLength)) padding += +tickLength;\n\n      if (isXAxis) {\n        // Add space for event section\n        lh += padding;\n        lh += eventSectionPadding;\n\n        if (pos == 'bottom') {\n          plotOffset.bottom += lh + axisMargin;\n          axis.box = {\n            top: surface.height - plotOffset.bottom,\n            height: lh\n          };\n        } else {\n          axis.box = {\n            top: plotOffset.top + axisMargin,\n            height: lh\n          };\n          plotOffset.top += lh + axisMargin;\n        }\n      } else {\n        lw += padding;\n\n        if (pos == 'left') {\n          axis.box = {\n            left: plotOffset.left + axisMargin,\n            width: lw\n          };\n          plotOffset.left += lw + axisMargin;\n        } else {\n          plotOffset.right += lw + axisMargin;\n          axis.box = {\n            left: surface.width - plotOffset.right,\n            width: lw\n          };\n        }\n      } // save for future reference\n\n\n      axis.position = pos;\n      axis.tickLength = tickLength;\n      axis.box.padding = padding;\n      axis.box.eventSectionPadding = eventSectionPadding;\n      axis.innermost = innermost;\n    }\n\n    function allocateAxisBoxSecondPhase(axis) {\n      // now that all axis boxes have been placed in one\n      // dimension, we can set the remaining dimension coordinates\n      if (axis.direction == 'x') {\n        axis.box.left = plotOffset.left - axis.labelWidth / 2;\n        axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\n      } else {\n        axis.box.top = plotOffset.top - axis.labelHeight / 2;\n        axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\n      }\n    }\n\n    function adjustLayoutForThingsStickingOut() {\n      // possibly adjust plot offset to ensure everything stays\n      // inside the canvas and isn't clipped off\n      var minMargin = options.grid.minBorderMargin,\n          i; // check stuff from the plot (FIXME: this should just read\n      // a value from the series, otherwise it's impossible to\n      // customize)\n\n      if (minMargin == null) {\n        minMargin = 0;\n\n        for (i = 0; i < series.length; ++i) {\n          minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth / 2));\n        }\n      }\n\n      var margins = {\n        left: minMargin,\n        right: minMargin,\n        top: minMargin,\n        bottom: minMargin\n      }; // check axis labels, note we don't check the actual\n      // labels but instead use the overall width/height to not\n      // jump as much around with replots\n\n      $.each(allAxes(), function (_, axis) {\n        if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n          if (axis.direction === 'x') {\n            margins.left = Math.max(margins.left, axis.labelWidth / 2);\n            margins.right = Math.max(margins.right, axis.labelWidth / 2);\n          } else {\n            margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n            margins.top = Math.max(margins.top, axis.labelHeight / 2);\n          }\n        }\n      });\n      plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n      plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n      plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n      plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\n    }\n\n    function setupGrid() {\n      var i,\n          axes = allAxes(),\n          showGrid = options.grid.show; // Initialize the plot's offset from the edge of the canvas\n\n      for (var a in plotOffset) {\n        var margin = options.grid.margin || 0;\n        plotOffset[a] = typeof margin == 'number' ? margin : margin[a] || 0;\n      }\n\n      executeHooks(hooks.processOffset, [plotOffset]); // If the grid is visible, add its border width to the offset\n\n      for (var a in plotOffset) {\n        if (typeof options.grid.borderWidth == 'object') {\n          plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\n        } else {\n          plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\n        }\n      }\n\n      $.each(axes, function (_, axis) {\n        var axisOpts = axis.options;\n        axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\n        axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\n        setRange(axis);\n      });\n      executeHooks(hooks.processRange, []);\n\n      if (showGrid) {\n        var allocatedAxes;\n        var i;\n\n        (function () {\n          allocatedAxes = $.grep(axes, function (axis) {\n            return axis.show || axis.reserveSpace;\n          });\n          var snaped = false;\n\n          for (i = 0; i < 2; i++) {\n            $.each(allocatedAxes, function (_, axis) {\n              // make the ticks\n              setupTickGeneration(axis);\n              setTicks(axis);\n              snaped = snapRangeToTicks(axis, axis.ticks) || snaped; // find labelWidth/Height for axis\n\n              measureTickLabels(axis);\n            });\n\n            if (snaped && hooks.processRange.length > 0) {\n              executeHooks(hooks.processRange, []);\n              snaped = false;\n            } else {\n              break;\n            }\n          } // with all dimensions calculated, we can compute the\n          // axis bounding boxes, start from the outside\n          // (reverse order)\n\n\n          for (i = allocatedAxes.length - 1; i >= 0; --i) {\n            allocateAxisBoxFirstPhase(allocatedAxes[i]);\n          } // make sure we've got enough space for things that\n          // might stick out\n\n\n          adjustLayoutForThingsStickingOut();\n          $.each(allocatedAxes, function (_, axis) {\n            allocateAxisBoxSecondPhase(axis);\n          });\n        })();\n      }\n\n      plotWidth = surface.width - plotOffset.left - plotOffset.right;\n      plotHeight = surface.height - plotOffset.bottom - plotOffset.top; // now we got the proper plot dimensions, we can compute the scaling\n\n      $.each(axes, function (_, axis) {\n        setTransformationHelpers(axis);\n      });\n\n      if (showGrid) {\n        drawAxisLabels();\n      }\n\n      insertLegend();\n    }\n\n    function setRange(axis) {\n      var opts = axis.options,\n          min = +(opts.min != null ? opts.min : axis.datamin),\n          max = +(opts.max != null ? opts.max : axis.datamax),\n          delta = max - min;\n\n      if (delta == 0.0) {\n        // Grafana fix: wide Y min and max using increased wideFactor\n        // when all series values are the same\n        var wideFactor = 0.25;\n        var widen = Math.abs(max == 0 ? 1 : max * wideFactor);\n\n        if (opts.min == null) {\n          min -= widen;\n        } // always widen max if we couldn't widen min to ensure we\n        // don't fall into min == max which doesn't work\n\n\n        if (opts.max == null || opts.min != null) {\n          max += widen;\n        }\n      } else {\n        // consider autoscaling\n        var margin = opts.autoscaleMargin;\n\n        if (margin != null) {\n          if (opts.min == null) {\n            min -= delta * margin; // make sure we don't go below zero if all values\n            // are positive\n\n            if (min < 0 && axis.datamin != null && axis.datamin >= 0) min = 0;\n          }\n\n          if (opts.max == null) {\n            max += delta * margin;\n            if (max > 0 && axis.datamax != null && axis.datamax <= 0) max = 0;\n          }\n        }\n      }\n\n      axis.min = min;\n      axis.max = max;\n    }\n\n    function setupTickGeneration(axis) {\n      var opts = axis.options; // estimate number of ticks\n\n      var noTicks;\n      if (typeof opts.ticks == 'number' && opts.ticks > 0) noTicks = opts.ticks; // heuristic based on the model a*sqrt(x) fitted to\n      // some data points that seemed reasonable\n      else noTicks = 0.3 * Math.sqrt(axis.direction == 'x' ? surface.width : surface.height);\n      var delta = (axis.max - axis.min) / noTicks,\n          dec = -Math.floor(Math.log(delta) / Math.LN10),\n          maxDec = opts.tickDecimals;\n\n      if (maxDec != null && dec > maxDec) {\n        dec = maxDec;\n      }\n\n      var magn = Math.pow(10, -dec),\n          norm = delta / magn,\n          // norm is between 1.0 and 10.0\n      size;\n\n      if (norm < 1.5) {\n        size = 1;\n      } else if (norm < 3) {\n        size = 2; // special case for 2.5, requires an extra decimal\n\n        if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\n          size = 2.5;\n          ++dec;\n        }\n      } else if (norm < 7.5) {\n        size = 5;\n      } else {\n        size = 10;\n      }\n\n      size *= magn;\n\n      if (opts.minTickSize != null && size < opts.minTickSize) {\n        size = opts.minTickSize;\n      }\n\n      axis.delta = delta;\n      axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\n      axis.tickSize = opts.tickSize || size; // grafana addition\n\n      if (opts.tickDecimals === null || opts.tickDecimals === undefined) {\n        axis.scaledDecimals = axis.tickDecimals + dec;\n      } // Time mode was moved to a plug-in in 0.8, and since so many people use it\n      // we'll add an especially friendly reminder to make sure they included it.\n\n\n      if (opts.mode == 'time' && !axis.tickGenerator) {\n        throw new Error('Time mode requires the flot.time plugin.');\n      } // Flot supports base-10 axes; any other mode else is handled by a plug-in,\n      // like flot.time.js.\n\n\n      if (!axis.tickGenerator) {\n        axis.tickGenerator = function (axis) {\n          var ticks = [],\n              start = floorInBase(axis.min, axis.tickSize),\n              i = 0,\n              v = Number.NaN,\n              prev;\n\n          do {\n            prev = v;\n            v = start + i * axis.tickSize;\n            ticks.push(v);\n            ++i;\n          } while (v < axis.max && v != prev);\n\n          return ticks;\n        };\n\n        axis.tickFormatter = function (value, axis) {\n          var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\n          var formatted = '' + Math.round(value * factor) / factor; // If tickDecimals was specified, ensure that we have exactly that\n          // much precision; otherwise default to the value's own precision.\n\n          if (axis.tickDecimals != null) {\n            var decimal = formatted.indexOf('.');\n            var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\n\n            if (precision < axis.tickDecimals) {\n              return (precision ? formatted : formatted + '.') + ('' + factor).substr(1, axis.tickDecimals - precision);\n            }\n          }\n\n          return formatted;\n        };\n      }\n\n      if ($.isFunction(opts.tickFormatter)) axis.tickFormatter = function (v, axis) {\n        return '' + opts.tickFormatter(v, axis);\n      };\n\n      if (opts.alignTicksWithAxis != null) {\n        var otherAxis = (axis.direction == 'x' ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n\n        if (otherAxis && otherAxis.used && otherAxis != axis) {\n          // consider snapping min/max to outermost nice ticks\n          var niceTicks = axis.tickGenerator(axis);\n\n          if (niceTicks.length > 0) {\n            if (opts.min == null) axis.min = Math.min(axis.min, niceTicks[0]);\n            if (opts.max == null && niceTicks.length > 1) axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n          }\n\n          axis.tickGenerator = function (axis) {\n            // copy ticks, scaled to this axis\n            var ticks = [],\n                v,\n                i;\n\n            for (i = 0; i < otherAxis.ticks.length; ++i) {\n              v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n              v = axis.min + v * (axis.max - axis.min);\n              ticks.push(v);\n            }\n\n            return ticks;\n          }; // we might need an extra decimal since forced\n          // ticks don't necessarily fit naturally\n\n\n          if (!axis.mode && opts.tickDecimals == null) {\n            var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n                ts = axis.tickGenerator(axis); // only proceed if the tick interval rounded\n            // with an extra decimal doesn't give us a\n            // zero at end\n\n            if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec)))) axis.tickDecimals = extraDec;\n          }\n        }\n      }\n    }\n\n    function setTicks(axis) {\n      var oticks = axis.options.ticks,\n          ticks = [];\n      if (oticks == null || typeof oticks == 'number' && oticks > 0) ticks = axis.tickGenerator(axis);else if (oticks) {\n        if ($.isFunction(oticks)) // generate the ticks\n          ticks = oticks(axis);else ticks = oticks;\n      } // clean up/labelify the supplied ticks, copy them over\n\n      var i, v;\n      axis.ticks = [];\n\n      for (i = 0; i < ticks.length; ++i) {\n        var label = null;\n        var t = ticks[i];\n\n        if (typeof t == 'object') {\n          v = +t[0];\n          if (t.length > 1) label = t[1];\n        } else v = +t;\n\n        if (label == null) label = axis.tickFormatter(v, axis);\n        if (!isNaN(v)) axis.ticks.push({\n          v: v,\n          label: label\n        });\n      }\n    }\n\n    function snapRangeToTicks(axis, ticks) {\n      var changed = false;\n\n      if (axis.options.autoscaleMargin && ticks.length > 0) {\n        // snap to ticks\n        if (axis.options.min == null) {\n          axis.min = Math.min(axis.min, ticks[0].v);\n          changed = true;\n        }\n\n        if (axis.options.max == null && ticks.length > 1) {\n          axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n          changed = true;\n        }\n      }\n\n      return changed;\n    }\n\n    function draw() {\n      surface.clear();\n      executeHooks(hooks.drawBackground, [ctx]);\n      var grid = options.grid; // draw background, if any\n\n      if (grid.show && grid.backgroundColor) drawBackground();\n\n      if (grid.show && !grid.aboveData) {\n        drawGrid();\n      }\n\n      for (var i = 0; i < series.length; ++i) {\n        executeHooks(hooks.drawSeries, [ctx, series[i]]);\n        drawSeries(series[i]);\n      }\n\n      executeHooks(hooks.draw, [ctx]);\n\n      if (grid.show && grid.aboveData) {\n        drawGrid();\n      }\n\n      surface.render(); // A draw implies that either the axes or data have changed, so we\n      // should probably update the overlay highlights as well.\n\n      triggerRedrawOverlay();\n    }\n\n    function extractRange(ranges, coord) {\n      var axis,\n          from,\n          to,\n          key,\n          axes = allAxes();\n\n      for (var i = 0; i < axes.length; ++i) {\n        axis = axes[i];\n\n        if (axis.direction == coord) {\n          key = coord + axis.n + 'axis';\n          if (!ranges[key] && axis.n == 1) key = coord + 'axis'; // support x1axis as xaxis\n\n          if (ranges[key]) {\n            from = ranges[key].from;\n            to = ranges[key].to;\n            break;\n          }\n        }\n      } // backwards-compat stuff - to be removed in future\n\n\n      if (!ranges[key]) {\n        axis = coord == 'x' ? xaxes[0] : yaxes[0];\n        from = ranges[coord + '1'];\n        to = ranges[coord + '2'];\n      } // auto-reverse as an added bonus\n\n\n      if (from != null && to != null && from > to) {\n        var tmp = from;\n        from = to;\n        to = tmp;\n      }\n\n      return {\n        from: from,\n        to: to,\n        axis: axis\n      };\n    }\n\n    function drawBackground() {\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top);\n      ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, 'rgba(255, 255, 255, 0)');\n      ctx.fillRect(0, 0, plotWidth, plotHeight);\n      ctx.restore();\n    }\n\n    function drawGrid() {\n      var i, axes, bw, bc;\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top); // draw markings\n\n      var markings = options.grid.markings;\n\n      if (markings) {\n        if ($.isFunction(markings)) {\n          axes = plot.getAxes(); // xmin etc. is backwards compatibility, to be\n          // removed in the future\n\n          axes.xmin = axes.xaxis.min;\n          axes.xmax = axes.xaxis.max;\n          axes.ymin = axes.yaxis.min;\n          axes.ymax = axes.yaxis.max;\n          markings = markings(axes);\n        }\n\n        for (i = 0; i < markings.length; ++i) {\n          var m = markings[i],\n              xrange = extractRange(m, 'x'),\n              yrange = extractRange(m, 'y'); // fill in missing\n\n          if (xrange.from == null) xrange.from = xrange.axis.min;\n          if (xrange.to == null) xrange.to = xrange.axis.max;\n          if (yrange.from == null) yrange.from = yrange.axis.min;\n          if (yrange.to == null) yrange.to = yrange.axis.max; // clip\n\n          if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max || yrange.to < yrange.axis.min || yrange.from > yrange.axis.max) continue;\n          xrange.from = Math.max(xrange.from, xrange.axis.min);\n          xrange.to = Math.min(xrange.to, xrange.axis.max);\n          yrange.from = Math.max(yrange.from, yrange.axis.min);\n          yrange.to = Math.min(yrange.to, yrange.axis.max);\n          var xequal = xrange.from === xrange.to,\n              yequal = yrange.from === yrange.to;\n\n          if (xequal && yequal) {\n            continue;\n          } // then draw\n\n\n          xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n          xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n          yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n          yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n\n          if (xequal || yequal) {\n            var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n                subPixel = lineWidth % 2 ? 0.5 : 0;\n            ctx.beginPath();\n            ctx.strokeStyle = m.color || options.grid.markingsColor;\n            ctx.lineWidth = lineWidth;\n\n            if (xequal) {\n              ctx.moveTo(xrange.to + subPixel, yrange.from);\n              ctx.lineTo(xrange.to + subPixel, yrange.to);\n            } else {\n              ctx.moveTo(xrange.from, yrange.to + subPixel);\n              ctx.lineTo(xrange.to, yrange.to + subPixel);\n            }\n\n            ctx.stroke();\n          } else {\n            ctx.fillStyle = m.color || options.grid.markingsColor;\n            ctx.fillRect(xrange.from, yrange.to, xrange.to - xrange.from, yrange.from - yrange.to);\n          }\n        }\n      } // draw the ticks\n\n\n      axes = allAxes();\n      bw = options.grid.borderWidth;\n\n      for (var j = 0; j < axes.length; ++j) {\n        var axis = axes[j],\n            box = axis.box,\n            t = axis.tickLength,\n            x,\n            y,\n            xoff,\n            yoff;\n        if (!axis.show || axis.ticks.length == 0) continue;\n        ctx.lineWidth = 1; // find the edges\n\n        if (axis.direction == 'x') {\n          x = 0;\n          if (t == 'full') y = axis.position == 'top' ? 0 : plotHeight;else y = box.top - plotOffset.top + (axis.position == 'top' ? box.height : 0);\n        } else {\n          y = 0;\n          if (t == 'full') x = axis.position == 'left' ? 0 : plotWidth;else x = box.left - plotOffset.left + (axis.position == 'left' ? box.width : 0);\n        } // draw tick bar\n\n\n        if (!axis.innermost) {\n          ctx.strokeStyle = axis.options.color;\n          ctx.beginPath();\n          xoff = yoff = 0;\n          if (axis.direction == 'x') xoff = plotWidth + 1;else yoff = plotHeight + 1;\n\n          if (ctx.lineWidth == 1) {\n            if (axis.direction == 'x') {\n              y = Math.floor(y) + 0.5;\n            } else {\n              x = Math.floor(x) + 0.5;\n            }\n          }\n\n          ctx.moveTo(x, y);\n          ctx.lineTo(x + xoff, y + yoff);\n          ctx.stroke();\n        } // draw ticks\n\n\n        ctx.strokeStyle = axis.options.tickColor;\n        ctx.beginPath();\n\n        for (i = 0; i < axis.ticks.length; ++i) {\n          var v = axis.ticks[i].v;\n          xoff = yoff = 0;\n          if (isNaN(v) || v < axis.min || v > axis.max || // skip those lying on the axes if we got a border\n          t == 'full' && (typeof bw == 'object' && bw[axis.position] > 0 || bw > 0) && (v == axis.min || v == axis.max)) continue;\n\n          if (axis.direction == 'x') {\n            x = axis.p2c(v);\n            yoff = t == 'full' ? -plotHeight : t;\n            if (axis.position == 'top') yoff = -yoff;\n          } else {\n            y = axis.p2c(v);\n            xoff = t == 'full' ? -plotWidth : t;\n            if (axis.position == 'left') xoff = -xoff;\n          }\n\n          if (ctx.lineWidth == 1) {\n            if (axis.direction == 'x') x = Math.floor(x) + 0.5;else y = Math.floor(y) + 0.5;\n          }\n\n          ctx.moveTo(x, y);\n          ctx.lineTo(x + xoff, y + yoff);\n        }\n\n        ctx.stroke();\n      } // draw border\n\n\n      if (bw) {\n        // If either borderWidth or borderColor is an object, then draw the border\n        // line by line instead of as one rectangle\n        bc = options.grid.borderColor;\n\n        if (typeof bw == 'object' || typeof bc == 'object') {\n          if (typeof bw !== 'object') {\n            bw = {\n              top: bw,\n              right: bw,\n              bottom: bw,\n              left: bw\n            };\n          }\n\n          if (typeof bc !== 'object') {\n            bc = {\n              top: bc,\n              right: bc,\n              bottom: bc,\n              left: bc\n            };\n          }\n\n          if (bw.top > 0) {\n            ctx.strokeStyle = bc.top;\n            ctx.lineWidth = bw.top;\n            ctx.beginPath();\n            ctx.moveTo(0 - bw.left, 0 - bw.top / 2);\n            ctx.lineTo(plotWidth, 0 - bw.top / 2);\n            ctx.stroke();\n          }\n\n          if (bw.right > 0) {\n            ctx.strokeStyle = bc.right;\n            ctx.lineWidth = bw.right;\n            ctx.beginPath();\n            ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n            ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n            ctx.stroke();\n          }\n\n          if (bw.bottom > 0) {\n            ctx.strokeStyle = bc.bottom;\n            ctx.lineWidth = bw.bottom;\n            ctx.beginPath();\n            ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n            ctx.lineTo(0, plotHeight + bw.bottom / 2);\n            ctx.stroke();\n          }\n\n          if (bw.left > 0) {\n            ctx.strokeStyle = bc.left;\n            ctx.lineWidth = bw.left;\n            ctx.beginPath();\n            ctx.moveTo(0 - bw.left / 2, plotHeight + bw.bottom);\n            ctx.lineTo(0 - bw.left / 2, 0);\n            ctx.stroke();\n          }\n        } else {\n          ctx.lineWidth = bw;\n          ctx.strokeStyle = options.grid.borderColor;\n          ctx.strokeRect(-bw / 2, -bw / 2, plotWidth + bw, plotHeight + bw);\n        }\n      }\n\n      ctx.restore();\n    }\n\n    function drawAxisLabels() {\n      $.each(allAxes(), function (_, axis) {\n        var box = axis.box,\n            legacyStyles = axis.direction + 'Axis ' + axis.direction + axis.n + 'Axis',\n            layer = 'flot-' + axis.direction + '-axis flot-' + axis.direction + axis.n + '-axis ' + legacyStyles,\n            font = axis.options.font || 'flot-tick-label tickLabel',\n            tick,\n            x,\n            y,\n            halign,\n            valign; // Remove text before checking for axis.show and ticks.length;\n        // otherwise plugins, like flot-tickrotor, that draw their own\n        // tick labels will end up with both theirs and the defaults.\n\n        surface.removeText(layer);\n        if (!axis.show || axis.ticks.length == 0) return;\n\n        for (var i = 0; i < axis.ticks.length; ++i) {\n          tick = axis.ticks[i];\n          if (!tick.label || tick.v < axis.min || tick.v > axis.max) continue;\n\n          if (axis.direction == 'x') {\n            halign = 'center';\n            x = plotOffset.left + axis.p2c(tick.v);\n\n            if (axis.position == 'bottom') {\n              y = box.top + box.padding + box.eventSectionPadding;\n            } else {\n              y = box.top + box.height - box.padding;\n              valign = 'bottom';\n            }\n          } else {\n            valign = 'middle';\n            y = plotOffset.top + axis.p2c(tick.v);\n\n            if (axis.position == 'left') {\n              x = box.left + box.width - box.padding;\n              halign = 'right';\n            } else {\n              x = box.left + box.padding;\n            }\n          }\n\n          surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\n        }\n      });\n    }\n\n    function drawOrphanedPoints(series) {\n      /* Filters series data for points with no neighbors before or after\n       * and plots single 0.5 radius points for them so that they are displayed.\n       */\n      var abandonedPoints = [];\n      var beforeX = null;\n      var afterX = null;\n      var datapoints = series.datapoints; // find any points with no neighbors before or after\n\n      var emptyPoints = [];\n\n      for (var j = 0; j < datapoints.pointsize - 2; j++) {\n        emptyPoints.push(0);\n      }\n\n      for (var i = 0; i < datapoints.points.length; i += datapoints.pointsize) {\n        var x = datapoints.points[i],\n            y = datapoints.points[i + 1];\n\n        if (i === datapoints.points.length - datapoints.pointsize) {\n          afterX = null;\n        } else {\n          afterX = datapoints.points[i + datapoints.pointsize];\n        }\n\n        if (x !== null && y !== null && beforeX === null && afterX === null) {\n          abandonedPoints.push(x);\n          abandonedPoints.push(y);\n          abandonedPoints.push.apply(abandonedPoints, emptyPoints);\n        }\n\n        beforeX = x;\n      }\n\n      var olddatapoints = datapoints.points;\n      datapoints.points = abandonedPoints;\n      series.points.radius = series.lines.lineWidth / 2; // plot the orphan points with a radius of lineWidth/2\n\n      drawSeriesPoints(series); // reset old info\n\n      datapoints.points = olddatapoints;\n    }\n\n    function drawSeries(series) {\n      if (series.lines.show) {\n        drawSeriesLines(series);\n\n        if (!series.points.show && !series.bars.show) {\n          // not necessary if user wants points displayed for everything\n          drawOrphanedPoints(series);\n        }\n      }\n\n      if (series.bars.show) drawSeriesBars(series);\n      if (series.points.show) drawSeriesPoints(series);\n    }\n\n    function drawSeriesLines(series) {\n      function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\n        var points = datapoints.points,\n            ps = datapoints.pointsize,\n            prevx = null,\n            prevy = null;\n        ctx.beginPath();\n\n        for (var i = ps; i < points.length; i += ps) {\n          var x1 = points[i - ps],\n              y1 = points[i - ps + 1],\n              x2 = points[i],\n              y2 = points[i + 1];\n          if (x1 == null || x2 == null) continue; // clip with ymin\n\n          if (y1 <= y2 && y1 < axisy.min) {\n            if (y2 < axisy.min) continue; // line segment is outside\n            // compute new intersection point\n\n            x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y1 = axisy.min;\n          } else if (y2 <= y1 && y2 < axisy.min) {\n            if (y1 < axisy.min) continue;\n            x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y2 = axisy.min;\n          } // clip with ymax\n\n\n          if (y1 >= y2 && y1 > axisy.max) {\n            if (y2 > axisy.max) continue;\n            x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y1 = axisy.max;\n          } else if (y2 >= y1 && y2 > axisy.max) {\n            if (y1 > axisy.max) continue;\n            x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y2 = axisy.max;\n          } // clip with xmin\n\n\n          if (x1 <= x2 && x1 < axisx.min) {\n            if (x2 < axisx.min) continue;\n            y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x1 = axisx.min;\n          } else if (x2 <= x1 && x2 < axisx.min) {\n            if (x1 < axisx.min) continue;\n            y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x2 = axisx.min;\n          } // clip with xmax\n\n\n          if (x1 >= x2 && x1 > axisx.max) {\n            if (x2 > axisx.max) continue;\n            y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x1 = axisx.max;\n          } else if (x2 >= x1 && x2 > axisx.max) {\n            if (x1 > axisx.max) continue;\n            y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x2 = axisx.max;\n          }\n\n          if (x1 != prevx || y1 != prevy) ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n          prevx = x2;\n          prevy = y2;\n          ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n        }\n\n        ctx.stroke();\n      }\n\n      function plotLineArea(datapoints, axisx, axisy) {\n        var points = datapoints.points,\n            ps = datapoints.pointsize,\n            bottom = Math.min(Math.max(0, axisy.min), axisy.max),\n            i = 0,\n            areaOpen = false,\n            ypos = 1,\n            segmentStart = 0,\n            segmentEnd = 0; // we process each segment in two turns, first forward\n        // direction to sketch out top, then once we hit the\n        // end we go backwards to sketch the bottom\n\n        while (true) {\n          if (ps > 0 && i > points.length + ps) break;\n          i += ps; // ps is negative if going backwards\n\n          var x1 = points[i - ps],\n              y1 = points[i - ps + ypos],\n              x2 = points[i],\n              y2 = points[i + ypos];\n\n          if (areaOpen) {\n            if (ps > 0 && x1 != null && x2 == null) {\n              // at turning point\n              segmentEnd = i;\n              ps = -ps;\n              ypos = 2;\n              continue;\n            }\n\n            if (ps < 0 && i == segmentStart + ps) {\n              // done with the reverse sweep\n              ctx.fill();\n              areaOpen = false;\n              ps = -ps;\n              ypos = 1;\n              i = segmentStart = segmentEnd + ps;\n              continue;\n            }\n          }\n\n          if (x1 == null || x2 == null) continue; // clip x values\n          // clip with xmin\n\n          if (x1 <= x2 && x1 < axisx.min) {\n            if (x2 < axisx.min) continue;\n            y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x1 = axisx.min;\n          } else if (x2 <= x1 && x2 < axisx.min) {\n            if (x1 < axisx.min) continue;\n            y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x2 = axisx.min;\n          } // clip with xmax\n\n\n          if (x1 >= x2 && x1 > axisx.max) {\n            if (x2 > axisx.max) continue;\n            y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x1 = axisx.max;\n          } else if (x2 >= x1 && x2 > axisx.max) {\n            if (x1 > axisx.max) continue;\n            y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n            x2 = axisx.max;\n          }\n\n          if (!areaOpen) {\n            // open area\n            ctx.beginPath();\n            ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n            areaOpen = true;\n          } // now first check the case where both is outside\n\n\n          if (y1 >= axisy.max && y2 >= axisy.max) {\n            ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n            ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n            continue;\n          } else if (y1 <= axisy.min && y2 <= axisy.min) {\n            ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n            ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n            continue;\n          } // else it's a bit more complicated, there might\n          // be a flat maxed out rectangle first, then a\n          // triangular cutout or reverse; to find these\n          // keep track of the current x values\n\n\n          var x1old = x1,\n              x2old = x2; // clip the y values, without shortcutting, we\n          // go through all cases in turn\n          // clip with ymin\n\n          if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n            x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y1 = axisy.min;\n          } else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n            x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y2 = axisy.min;\n          } // clip with ymax\n\n\n          if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n            x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y1 = axisy.max;\n          } else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n            x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n            y2 = axisy.max;\n          } // if the x value was changed we got a rectangle\n          // to fill\n\n\n          if (x1 != x1old) {\n            ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1)); // it goes to (x1, y1), but we fill that below\n          } // fill triangular section, this sometimes result\n          // in redundant points if (x1, y1) hasn't changed\n          // from previous line to, but we just ignore that\n\n\n          ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n          ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2)); // fill the other rectangle if it's there\n\n          if (x2 != x2old) {\n            ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n            ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n          }\n        }\n      }\n\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top);\n      ctx.lineJoin = 'round';\n      var lw = series.lines.lineWidth,\n          sw = series.shadowSize; // FIXME: consider another form of shadow when filling is turned on\n\n      if (lw > 0 && sw > 0) {\n        // draw shadow as a thick and thin line with transparency\n        ctx.lineWidth = sw;\n        ctx.strokeStyle = 'rgba(0,0,0,0.1)'; // position shadow at angle from the mid of line\n\n        var angle = Math.PI / 18;\n        plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 2), Math.cos(angle) * (lw / 2 + sw / 2), series.xaxis, series.yaxis);\n        ctx.lineWidth = sw / 2;\n        plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 4), Math.cos(angle) * (lw / 2 + sw / 4), series.xaxis, series.yaxis);\n      }\n\n      ctx.lineWidth = lw;\n      ctx.strokeStyle = series.color;\n      var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\n\n      if (fillStyle) {\n        ctx.fillStyle = fillStyle;\n        plotLineArea(series.datapoints, series.xaxis, series.yaxis);\n      }\n\n      if (lw > 0) plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\n      ctx.restore();\n    }\n\n    function drawSeriesPoints(series) {\n      function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\n        var points = datapoints.points,\n            ps = datapoints.pointsize;\n\n        for (var i = 0; i < points.length; i += ps) {\n          var x = points[i],\n              y = points[i + 1];\n          if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) continue;\n          ctx.beginPath();\n          x = axisx.p2c(x);\n          y = axisy.p2c(y) + offset;\n          if (symbol == 'circle') ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);else symbol(ctx, x, y, radius, shadow);\n          ctx.closePath();\n\n          if (fillStyle) {\n            ctx.fillStyle = fillStyle;\n            ctx.fill();\n          }\n\n          ctx.stroke();\n        }\n      }\n\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top);\n      var lw = series.points.lineWidth,\n          sw = series.shadowSize,\n          radius = series.points.radius,\n          symbol = series.points.symbol; // If the user sets the line width to 0, we change it to a very\n      // small value. A line width of 0 seems to force the default of 1.\n      // Doing the conditional here allows the shadow setting to still be\n      // optional even with a lineWidth of 0.\n\n      if (lw == 0) lw = 0.0001;\n\n      if (lw > 0 && sw > 0) {\n        // draw shadow in two steps\n        var w = sw / 2;\n        ctx.lineWidth = w;\n        ctx.strokeStyle = 'rgba(0,0,0,0.1)';\n        plotPoints(series.datapoints, radius, null, w + w / 2, true, series.xaxis, series.yaxis, symbol);\n        ctx.strokeStyle = 'rgba(0,0,0,0.2)';\n        plotPoints(series.datapoints, radius, null, w / 2, true, series.xaxis, series.yaxis, symbol);\n      }\n\n      ctx.lineWidth = lw;\n      ctx.strokeStyle = series.color;\n      plotPoints(series.datapoints, radius, getFillStyle(series.points, series.color), 0, false, series.xaxis, series.yaxis, symbol);\n      ctx.restore();\n    }\n\n    function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n      var left, right, bottom, top, drawLeft, drawRight, drawTop, drawBottom, tmp; // in horizontal mode, we start the bar from the left\n      // instead of from the bottom so it appears to be\n      // horizontal rather than vertical\n\n      if (horizontal) {\n        drawBottom = drawRight = drawTop = true;\n        drawLeft = false;\n        left = b;\n        right = x;\n        top = y + barLeft;\n        bottom = y + barRight; // account for negative bars\n\n        if (right < left) {\n          tmp = right;\n          right = left;\n          left = tmp;\n          drawLeft = true;\n          drawRight = false;\n        }\n      } else {\n        drawLeft = drawRight = drawTop = true;\n        drawBottom = false;\n        left = x + barLeft;\n        right = x + barRight;\n        bottom = b;\n        top = y; // account for negative bars\n\n        if (top < bottom) {\n          tmp = top;\n          top = bottom;\n          bottom = tmp;\n          drawBottom = true;\n          drawTop = false;\n        }\n      } // clip\n\n\n      if (right < axisx.min || left > axisx.max || top < axisy.min || bottom > axisy.max) return;\n\n      if (left < axisx.min) {\n        left = axisx.min;\n        drawLeft = false;\n      }\n\n      if (right > axisx.max) {\n        right = axisx.max;\n        drawRight = false;\n      }\n\n      if (bottom < axisy.min) {\n        bottom = axisy.min;\n        drawBottom = false;\n      }\n\n      if (top > axisy.max) {\n        top = axisy.max;\n        drawTop = false;\n      }\n\n      left = axisx.p2c(left);\n      bottom = axisy.p2c(bottom);\n      right = axisx.p2c(right);\n      top = axisy.p2c(top); // fill the bar\n\n      if (fillStyleCallback) {\n        c.fillStyle = fillStyleCallback(bottom, top);\n        c.fillRect(left, top, right - left, bottom - top);\n      } // draw outline\n\n\n      if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n        c.beginPath(); // FIXME: inline moveTo is buggy with excanvas\n\n        c.moveTo(left, bottom);\n        if (drawLeft) c.lineTo(left, top);else c.moveTo(left, top);\n        if (drawTop) c.lineTo(right, top);else c.moveTo(right, top);\n        if (drawRight) c.lineTo(right, bottom);else c.moveTo(right, bottom);\n        if (drawBottom) c.lineTo(left, bottom);else c.moveTo(left, bottom);\n        c.stroke();\n      }\n    }\n\n    function drawSeriesBars(series) {\n      function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n        var points = datapoints.points,\n            ps = datapoints.pointsize;\n\n        for (var i = 0; i < points.length; i += ps) {\n          if (points[i] == null) continue;\n          drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\n        }\n      }\n\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top); // FIXME: figure out a way to add shadows (for instance along the right edge)\n\n      ctx.lineWidth = series.bars.lineWidth;\n      ctx.strokeStyle = series.color;\n      var barLeft;\n\n      switch (series.bars.align) {\n        case 'left':\n          barLeft = 0;\n          break;\n\n        case 'right':\n          barLeft = -series.bars.barWidth;\n          break;\n\n        default:\n          barLeft = -series.bars.barWidth / 2;\n      }\n\n      var fillStyleCallback = series.bars.fill ? function (bottom, top) {\n        return getFillStyle(series.bars, series.color, bottom, top);\n      } : null;\n      plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n      ctx.restore();\n    }\n\n    function getFillStyle(filloptions, seriesColor, bottom, top) {\n      var fill = filloptions.fill;\n      if (!fill) return null;\n      if (filloptions.fillColor) return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n      var c = $.color.parse(seriesColor);\n      c.a = typeof fill == 'number' ? fill : 0.4;\n      c.normalize();\n      return c.toString();\n    }\n\n    function insertLegend() {\n      if (options.legend.container != null) {\n        $(options.legend.container).html('');\n      } else {\n        placeholder.find('.legend').remove();\n      }\n\n      if (!options.legend.show) {\n        return;\n      }\n\n      var fragments = [],\n          entries = [],\n          rowStarted = false,\n          lf = options.legend.labelFormatter,\n          s,\n          label; // Build a list of legend entries, with each having a label and a color\n\n      for (var i = 0; i < series.length; ++i) {\n        s = series[i];\n\n        if (s.label) {\n          label = lf ? lf(s.label, s) : s.label;\n\n          if (label) {\n            entries.push({\n              label: label,\n              color: s.color\n            });\n          }\n        }\n      } // Sort the legend using either the default or a custom comparator\n\n\n      if (options.legend.sorted) {\n        if ($.isFunction(options.legend.sorted)) {\n          entries.sort(options.legend.sorted);\n        } else if (options.legend.sorted == 'reverse') {\n          entries.reverse();\n        } else {\n          var ascending = options.legend.sorted != 'descending';\n          entries.sort(function (a, b) {\n            // eslint-disable-next-line\n            return a.label == b.label ? 0 : a.label < b.label != ascending ? 1 : -1; // Logical XOR\n          });\n        }\n      } // Generate markup for the list of entries, in their final order\n\n\n      for (var i = 0; i < entries.length; ++i) {\n        var entry = entries[i];\n\n        if (i % options.legend.noColumns == 0) {\n          if (rowStarted) fragments.push('</tr>');\n          fragments.push('<tr>');\n          rowStarted = true;\n        }\n\n        fragments.push('<td class=\"legendColorBox\"><div style=\"border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden\"></div></div></td>' + '<td class=\"legendLabel\">' + entry.label + '</td>');\n      }\n\n      if (rowStarted) fragments.push('</tr>');\n      if (fragments.length == 0) return;\n      var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join('') + '</table>';\n      if (options.legend.container != null) $(options.legend.container).html(table);else {\n        var pos = '',\n            p = options.legend.position,\n            m = options.legend.margin;\n        if (m[0] == null) m = [m, m];\n        if (p.charAt(0) == 'n') pos += 'top:' + (m[1] + plotOffset.top) + 'px;';else if (p.charAt(0) == 's') pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n        if (p.charAt(1) == 'e') pos += 'right:' + (m[0] + plotOffset.right) + 'px;';else if (p.charAt(1) == 'w') pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n        var legend = $('<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos + ';') + '</div>').appendTo(placeholder);\n\n        if (options.legend.backgroundOpacity != 0.0) {\n          // put in the transparent background\n          // separately to avoid blended labels and\n          // label boxes\n          var c = options.legend.backgroundColor;\n\n          if (c == null) {\n            c = options.grid.backgroundColor;\n            if (c && typeof c == 'string') c = $.color.parse(c);else c = $.color.extract(legend, 'background-color');\n            c.a = 1;\n            c = c.toString();\n          }\n\n          var div = legend.children();\n          $('<div style=\"position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos + 'background-color:' + c + ';\"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);\n        }\n      }\n    } // interactive features\n\n\n    var highlights = [],\n        redrawTimeout = null; // returns the data item the mouse is over, or null if none is found\n\n    function findNearbyItem(mouseX, mouseY, seriesFilter) {\n      var maxDistance = options.grid.mouseActiveRadius,\n          smallestDistance = maxDistance * maxDistance + 1,\n          item = null,\n          i,\n          j,\n          ps;\n\n      for (i = series.length - 1; i >= 0; --i) {\n        if (!seriesFilter(series[i])) continue;\n        var s = series[i],\n            axisx = s.xaxis,\n            axisy = s.yaxis,\n            points = s.datapoints.points,\n            mx = axisx.c2p(mouseX),\n            // precompute some stuff to make the loop faster\n        my = axisy.c2p(mouseY),\n            maxx = maxDistance / axisx.scale,\n            maxy = maxDistance / axisy.scale;\n        ps = s.datapoints.pointsize; // with inverse transforms, we can't use the maxx/maxy\n        // optimization, sadly\n\n        if (axisx.options.inverseTransform) maxx = Number.MAX_VALUE;\n        if (axisy.options.inverseTransform) maxy = Number.MAX_VALUE;\n\n        if (s.lines.show || s.points.show) {\n          for (j = 0; j < points.length; j += ps) {\n            var x = points[j],\n                y = points[j + 1];\n            if (x == null) continue; // For points and lines, the cursor must be within a\n            // certain distance to the data point\n\n            if (x - mx > maxx || x - mx < -maxx || y - my > maxy || y - my < -maxy) continue; // We have to calculate distances in pixels, not in\n            // data units, because the scales of the axes may be different\n\n            var dx = Math.abs(axisx.p2c(x) - mouseX),\n                dy = Math.abs(axisy.p2c(y) - mouseY),\n                dist = dx * dx + dy * dy; // we save the sqrt\n            // use <= to ensure last point takes precedence\n            // (last generally means on top of)\n\n            if (dist < smallestDistance) {\n              smallestDistance = dist;\n              item = [i, j / ps];\n            }\n          }\n        }\n\n        if (s.bars.show && !item) {\n          // no other point can be nearby\n          var barLeft, barRight;\n\n          switch (s.bars.align) {\n            case 'left':\n              barLeft = 0;\n              break;\n\n            case 'right':\n              barLeft = -s.bars.barWidth;\n              break;\n\n            default:\n              barLeft = -s.bars.barWidth / 2;\n          }\n\n          barRight = barLeft + s.bars.barWidth;\n\n          for (j = 0; j < points.length; j += ps) {\n            var x = points[j],\n                y = points[j + 1],\n                b = points[j + 2];\n            if (x == null) continue; // for a bar graph, the cursor must be inside the bar\n\n            if (series[i].bars.horizontal ? mx <= Math.max(b, x) && mx >= Math.min(b, x) && my >= y + barLeft && my <= y + barRight : mx >= x + barLeft && mx <= x + barRight && my >= Math.min(b, y) && my <= Math.max(b, y)) item = [i, j / ps];\n          }\n        }\n      }\n\n      if (item) {\n        i = item[0];\n        j = item[1];\n        ps = series[i].datapoints.pointsize;\n        return {\n          datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n          dataIndex: j,\n          series: series[i],\n          seriesIndex: i\n        };\n      }\n\n      return null;\n    }\n\n    function onMouseMove(e) {\n      if (options.grid.hoverable) triggerClickHoverEvent('plothover', e, function (s) {\n        return s['hoverable'] != false;\n      });\n    }\n\n    function onMouseLeave(e) {\n      if (options.grid.hoverable) triggerClickHoverEvent('plothover', e, function () {\n        return false;\n      });\n    }\n\n    function onClick(e) {\n      if (plot.isSelecting) {\n        return;\n      }\n\n      triggerClickHoverEvent('plotclick', e, function (s) {\n        return s['clickable'] != false;\n      });\n    } // trigger click or hover event (they send the same parameters\n    // so we share their code)\n\n\n    function triggerClickHoverEvent(eventname, event, seriesFilter) {\n      var offset = eventHolder.offset(),\n          canvasX = event.pageX - offset.left - plotOffset.left,\n          canvasY = event.pageY - offset.top - plotOffset.top,\n          pos = canvasToAxisCoords({\n        left: canvasX,\n        top: canvasY\n      });\n      pos.pageX = event.pageX;\n      pos.pageY = event.pageY; // Add ctrlKey and metaKey to event\n\n      pos.ctrlKey = event.ctrlKey;\n      pos.metaKey = event.metaKey;\n      var item = findNearbyItem(canvasX, canvasY, seriesFilter);\n\n      if (item) {\n        // fill in mouse pos for any listeners out there\n        item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\n        item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);\n      }\n\n      if (options.grid.autoHighlight) {\n        // clear auto-highlights\n        for (var i = 0; i < highlights.length; ++i) {\n          var h = highlights[i];\n          if (h.auto == eventname && !(item && h.series == item.series && h.point[0] == item.datapoint[0] && h.point[1] == item.datapoint[1])) unhighlight(h.series, h.point);\n        }\n\n        if (item) highlight(item.series, item.datapoint, eventname);\n      }\n\n      placeholder.trigger(eventname, [pos, item]);\n    }\n\n    function triggerRedrawOverlay() {\n      var t = options.interaction.redrawOverlayInterval;\n\n      if (t == -1) {\n        // skip event queue\n        drawOverlay();\n        return;\n      }\n\n      if (!redrawTimeout) redrawTimeout = setTimeout(drawOverlay, t);\n    }\n\n    function drawOverlay() {\n      redrawTimeout = null; // draw highlights\n\n      octx.save();\n      overlay.clear();\n      octx.translate(plotOffset.left, plotOffset.top);\n      var i, hi;\n\n      for (i = 0; i < highlights.length; ++i) {\n        hi = highlights[i];\n        if (hi.series.bars.show) drawBarHighlight(hi.series, hi.point);else drawPointHighlight(hi.series, hi.point);\n      }\n\n      octx.restore();\n      executeHooks(hooks.drawOverlay, [octx]);\n    }\n\n    function highlight(s, point, auto) {\n      if (typeof s == 'number') s = series[s];\n\n      if (typeof point == 'number') {\n        var ps = s.datapoints.pointsize;\n        point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n      }\n\n      var i = indexOfHighlight(s, point);\n\n      if (i == -1) {\n        highlights.push({\n          series: s,\n          point: point,\n          auto: auto\n        });\n        triggerRedrawOverlay();\n      } else if (!auto) highlights[i].auto = false;\n    }\n\n    function unhighlight(s, point) {\n      if (s == null && point == null) {\n        highlights = [];\n        triggerRedrawOverlay();\n        return;\n      }\n\n      if (typeof s == 'number') s = series[s];\n\n      if (typeof point == 'number') {\n        var ps = s.datapoints.pointsize;\n        point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n      }\n\n      var i = indexOfHighlight(s, point);\n\n      if (i != -1) {\n        highlights.splice(i, 1);\n        triggerRedrawOverlay();\n      }\n    }\n\n    function indexOfHighlight(s, p) {\n      for (var i = 0; i < highlights.length; ++i) {\n        var h = highlights[i];\n        if (h.series == s && h.point[0] == p[0] && h.point[1] == p[1]) return i;\n      }\n\n      return -1;\n    }\n\n    function drawPointHighlight(series, point) {\n      var x = point[0],\n          y = point[1],\n          axisx = series.xaxis,\n          axisy = series.yaxis,\n          highlightColor = typeof series.highlightColor === 'string' ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\n      if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) return;\n      var pointRadius = series.points.radius + series.points.lineWidth / 2;\n      octx.lineWidth = pointRadius;\n      octx.strokeStyle = highlightColor;\n      var radius = 1.5 * pointRadius;\n      x = axisx.p2c(x);\n      y = axisy.p2c(y);\n      octx.beginPath();\n      if (series.points.symbol == 'circle') octx.arc(x, y, radius, 0, 2 * Math.PI, false);else series.points.symbol(octx, x, y, radius, false);\n      octx.closePath();\n      octx.stroke();\n    }\n\n    function drawBarHighlight(series, point) {\n      var highlightColor = typeof series.highlightColor === 'string' ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\n          fillStyle = highlightColor,\n          barLeft;\n\n      switch (series.bars.align) {\n        case 'left':\n          barLeft = 0;\n          break;\n\n        case 'right':\n          barLeft = -series.bars.barWidth;\n          break;\n\n        default:\n          barLeft = -series.bars.barWidth / 2;\n      }\n\n      octx.lineWidth = series.bars.lineWidth;\n      octx.strokeStyle = highlightColor;\n      drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth, function () {\n        return fillStyle;\n      }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\n    }\n\n    function getColorOrGradient(spec, bottom, top, defaultColor) {\n      if (typeof spec == 'string') return spec;else {\n        // assume this is a gradient spec; IE currently only\n        // supports a simple vertical gradient properly, so that's\n        // what we support too\n        var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n\n        for (var i = 0, l = spec.colors.length; i < l; ++i) {\n          var c = spec.colors[i];\n\n          if (typeof c != 'string') {\n            var co = $.color.parse(defaultColor);\n            if (c.brightness != null) co = co.scale('rgb', c.brightness);\n            if (c.opacity != null) co.a *= c.opacity;\n            c = co.toString();\n          }\n\n          gradient.addColorStop(i / (l - 1), c);\n        }\n\n        return gradient;\n      }\n    }\n  } // Add the plot function to the top level of the jQuery object\n\n\n  $.plot = function (placeholder, data, options) {\n    //var t0 = new Date();\n    var plot = new Plot($(placeholder), data, options, $.plot.plugins); //(window.console ? console.log : alert)(\"time used (msecs): \" + ((new Date()).getTime() - t0.getTime()));\n\n    return plot;\n  };\n\n  $.plot.version = '0.8.3';\n  $.plot.plugins = []; // Also add the plot function as a chainable property\n\n  $.fn.plot = function (data, options) {\n    return this.each(function () {\n      $.plot(this, data, options);\n    });\n  }; // round to nearby lower multiple of base\n\n\n  function floorInBase(n, base) {\n    return base * Math.floor(n / base);\n  }\n})(window.jQuery);","map":{"version":3,"sources":["/app/src/vendor/flot/jquery.flot.js"],"names":["$","color","make","r","g","b","a","o","add","c","d","i","length","charAt","normalize","scale","f","toString","join","clamp","min","value","max","parseInt","clone","extract","elem","css","toLowerCase","parent","nodeName","get","parse","str","res","m","exec","parseFloat","name","trim","lookupColors","aqua","azure","beige","black","blue","brown","cyan","darkblue","darkcyan","darkgrey","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkviolet","fuchsia","gold","green","indigo","khaki","lightblue","lightcyan","lightgreen","lightgrey","lightpink","lightyellow","lime","magenta","maroon","navy","olive","orange","pink","purple","violet","red","silver","white","yellow","window","jQuery","hasOwnProperty","Object","prototype","fn","detach","each","parentNode","removeChild","Canvas","cls","container","element","children","document","createElement","className","direction","position","left","top","appendTo","getContext","G_vmlCanvasManager","initElement","Error","context","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","pixelRatio","resize","width","height","textContainer","text","_textCache","_textSizeCache","flotTextSizeCache","style","restore","save","clear","clearRect","render","cache","layerKey","call","layer","getTextLayer","layerCache","hide","styleKey","styleCache","key","positions","active","rendered","append","splice","show","classes","bottom","right","insertAfter","addClass","getTextInfo","font","angle","textStyle","info","variant","weight","size","lineHeight","family","html","outerWidth","outerHeight","addText","x","y","halign","valign","push","Math","round","removeText","Plot","placeholder","data_","options_","plugins","series","options","colors","legend","noColumns","labelFormatter","labelBoxBorderColor","margin","backgroundColor","backgroundOpacity","sorted","xaxis","mode","tickColor","transform","inverseTransform","autoscaleMargin","ticks","tickFormatter","labelWidth","labelHeight","reserveSpace","tickLength","alignTicksWithAxis","tickDecimals","tickSize","minTickSize","yaxis","xaxes","yaxes","points","radius","lineWidth","fill","fillColor","symbol","lines","steps","bars","barWidth","align","horizontal","zero","shadowSize","highlightColor","grid","aboveData","borderColor","labelMargin","eventSectionHeight","axisMargin","borderWidth","minBorderMargin","markings","markingsColor","markingsLineWidth","clickable","hoverable","autoHighlight","mouseActiveRadius","interaction","redrawOverlayInterval","hooks","surface","overlay","eventHolder","ctx","octx","plotOffset","plotWidth","plotHeight","processOptions","processRawData","processDatapoints","processOffset","processRange","drawBackground","drawSeries","draw","bindEvents","drawOverlay","shutdown","plot","setData","setupGrid","getPlaceholder","getCanvas","getPlotOffset","offset","getData","getAxes","concat","_","axis","n","getXAxes","getYAxes","c2p","canvasToAxisCoords","p2c","axisToCanvasCoords","getOptions","highlight","unhighlight","triggerRedrawOverlay","pointOffset","point","axisNumber","destroy","removeData","empty","highlights","initPlugins","parseOptions","setupCanvases","executeHooks","hook","args","apply","p","init","extend","opts","axisOptions","axisCount","fontSize","fontSizeDefault","replace","fontDefaults","noTicks","x2axis","y2axis","coloredAreas","coloredAreasColor","getOrCreateAxis","parseData","fillInSeriesOptions","processData","s","data","obj","coord","allAxes","grep","pos","x1","undefined","y1","used","axes","number","neededColors","maxIndex","sc","colorPool","colorPoolSize","variation","colori","v","topSentry","Number","POSITIVE_INFINITY","bottomSentry","NEGATIVE_INFINITY","fakeInfinity","MAX_VALUE","j","k","ps","val","format","updateAxis","datamin","datamax","datapoints","required","stack","autoscale","defaultValue","pointsize","insertSteps","nullify","isNaN","Infinity","xmin","ymin","xmax","ymax","delta","find","remove","unbind","existing","mousemove","onMouseMove","bind","onMouseLeave","click","onClick","redrawTimeout","clearTimeout","setTransformationHelpers","identity","t","it","abs","measureTickLabels","maxWidth","floor","legacyStyles","label","allocateAxisBoxFirstPhase","lw","lh","isXAxis","padding","eventSectionPadding","innermost","outermost","first","found","box","allocateAxisBoxSecondPhase","adjustLayoutForThingsStickingOut","minMargin","margins","ceil","showGrid","axisOpts","setRange","allocatedAxes","snaped","setupTickGeneration","setTicks","snapRangeToTicks","drawAxisLabels","insertLegend","wideFactor","widen","sqrt","dec","log","LN10","maxDec","magn","pow","norm","scaledDecimals","tickGenerator","start","floorInBase","NaN","prev","factor","formatted","decimal","indexOf","precision","substr","isFunction","otherAxis","niceTicks","extraDec","ts","test","toFixed","oticks","changed","drawGrid","extractRange","ranges","from","to","tmp","translate","fillStyle","getColorOrGradient","fillRect","bw","bc","xrange","yrange","xequal","yequal","subPixel","beginPath","strokeStyle","moveTo","lineTo","stroke","xoff","yoff","strokeRect","tick","drawOrphanedPoints","abandonedPoints","beforeX","afterX","emptyPoints","olddatapoints","drawSeriesPoints","drawSeriesLines","drawSeriesBars","plotLine","xoffset","yoffset","axisx","axisy","prevx","prevy","x2","y2","plotLineArea","areaOpen","ypos","segmentStart","segmentEnd","x1old","x2old","lineJoin","sw","PI","sin","cos","getFillStyle","plotPoints","shadow","arc","closePath","w","drawBar","barLeft","barRight","fillStyleCallback","drawLeft","drawRight","drawTop","drawBottom","plotBars","filloptions","seriesColor","fragments","entries","rowStarted","lf","sort","reverse","ascending","entry","table","div","prependTo","findNearbyItem","mouseX","mouseY","seriesFilter","maxDistance","smallestDistance","item","mx","my","maxx","maxy","dx","dy","dist","datapoint","slice","dataIndex","seriesIndex","e","triggerClickHoverEvent","isSelecting","eventname","event","canvasX","pageX","canvasY","pageY","ctrlKey","metaKey","h","auto","trigger","setTimeout","hi","drawBarHighlight","drawPointHighlight","indexOfHighlight","pointRadius","spec","defaultColor","gradient","createLinearGradient","l","co","brightness","opacity","addColorStop","version","base"],"mappings":"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","sourcesContent":["/**\n *\n * THIS FILE WAS COPIED INTO PROMETHEUS FROM GRAFANA'S VENDORED FORK OF FLOT\n * (LIVING AT https://github.com/grafana/grafana/tree/master/public/vendor/flot),\n * WHICH CONTAINS FIXES FOR DISPLAYING NULL VALUES IN STACKED GRAPHS. THE ORIGINAL\n * FLOT CODE WAS LICENSED UNDER THE MIT LICENSE AS STATED BELOW. ADDITIONAL\n * CHANGES HAVE BEEN CONTRIBUTED TO THE GRAFANA FORK UNDER AN APACHE 2 LICENSE, SEE\n * https://github.com/grafana/grafana/blob/master/license.\n *\n */\n\n/* eslint-disable prefer-spread */\n/* eslint-disable no-loop-func */\n/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-redeclare */\n/* eslint-disable no-useless-escape */\n/* eslint-disable prefer-const */\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n/* eslint-disable @typescript-eslint/no-use-before-define */\n/* eslint-disable eqeqeq */\n/* eslint-disable no-var */\n/* Javascript plotting library for jQuery, version 0.8.3.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\n*/\n\n// first an inline dependency, jquery.colorhelpers.js, we inline it here\n// for convenience\n\n/* Plugin for jQuery for working with colors.\n *\n * Version 1.1.\n *\n * Inspiration from jQuery color animation plugin by John Resig.\n *\n * Released under the MIT license by Ole Laursen, October 2009.\n *\n * Examples:\n *\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\n *   console.log(c.r, c.g, c.b, c.a);\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\n *\n * Note that .scale() and .add() return the same modified object\n * instead of making a new one.\n *\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\n * produce a color rather than just crashing.\n */\n\n(function($) {\n  $.color = {};\n  $.color.make = function(r, g, b, a) {\n    var o = {};\n    o.r = r || 0;\n    o.g = g || 0;\n    o.b = b || 0;\n    o.a = a != null ? a : 1;\n    o.add = function(c, d) {\n      for (var i = 0; i < c.length; ++i) o[c.charAt(i)] += d;\n      return o.normalize();\n    };\n    o.scale = function(c, f) {\n      for (var i = 0; i < c.length; ++i) o[c.charAt(i)] *= f;\n      return o.normalize();\n    };\n    o.toString = function() {\n      if (o.a >= 1) {\n        return 'rgb(' + [o.r, o.g, o.b].join(',') + ')';\n      } else {\n        return 'rgba(' + [o.r, o.g, o.b, o.a].join(',') + ')';\n      }\n    };\n    o.normalize = function() {\n      function clamp(min, value, max) {\n        return value < min ? min : value > max ? max : value;\n      }\n      o.r = clamp(0, parseInt(o.r), 255);\n      o.g = clamp(0, parseInt(o.g), 255);\n      o.b = clamp(0, parseInt(o.b), 255);\n      o.a = clamp(0, o.a, 1);\n      return o;\n    };\n    o.clone = function() {\n      return $.color.make(o.r, o.b, o.g, o.a);\n    };\n    return o.normalize();\n  };\n  $.color.extract = function(elem, css) {\n    var c;\n    do {\n      c = elem.css(css).toLowerCase();\n      if (c != '' && c != 'transparent') break;\n      elem = elem.parent();\n    } while (elem.length && !$.nodeName(elem.get(0), 'body'));\n    if (c == 'rgba(0, 0, 0, 0)') c = 'transparent';\n    return $.color.parse(c);\n  };\n  $.color.parse = function(str) {\n    var res,\n      m = $.color.make;\n    if ((res = /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str)))\n      return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10));\n    if ((res = /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str)))\n      return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10), parseFloat(res[4]));\n    if ((res = /rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(str)))\n      return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55);\n    if (\n      (res = /rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(\n        str\n      ))\n    )\n      return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55, parseFloat(res[4]));\n    if ((res = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str)))\n      return m(parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16));\n    if ((res = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str)))\n      return m(parseInt(res[1] + res[1], 16), parseInt(res[2] + res[2], 16), parseInt(res[3] + res[3], 16));\n    var name = $.trim(str).toLowerCase();\n    if (name == 'transparent') return m(255, 255, 255, 0);\n    else {\n      res = lookupColors[name] || [0, 0, 0];\n      return m(res[0], res[1], res[2]);\n    }\n  };\n  var lookupColors = {\n    aqua: [0, 255, 255],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    black: [0, 0, 0],\n    blue: [0, 0, 255],\n    brown: [165, 42, 42],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgrey: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkviolet: [148, 0, 211],\n    fuchsia: [255, 0, 255],\n    gold: [255, 215, 0],\n    green: [0, 128, 0],\n    indigo: [75, 0, 130],\n    khaki: [240, 230, 140],\n    lightblue: [173, 216, 230],\n    lightcyan: [224, 255, 255],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    navy: [0, 0, 128],\n    olive: [128, 128, 0],\n    orange: [255, 165, 0],\n    pink: [255, 192, 203],\n    purple: [128, 0, 128],\n    violet: [128, 0, 128],\n    red: [255, 0, 0],\n    silver: [192, 192, 192],\n    white: [255, 255, 255],\n    yellow: [255, 255, 0],\n  };\n})(window.jQuery);\n\n// the actual Flot code\n(function($) {\n  // Cache the prototype hasOwnProperty for faster access\n\n  let hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM\n  // operation produces the same effect as detach, i.e. removing the element\n  // without touching its jQuery data.\n\n  // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.\n\n  if (!$.fn.detach) {\n    $.fn.detach = function() {\n      return this.each(function() {\n        if (this.parentNode) {\n          this.parentNode.removeChild(this);\n        }\n      });\n    };\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  // The Canvas object is a wrapper around an HTML5 <canvas> tag.\n  //\n  // @constructor\n  // @param {string} cls List of classes to apply to the canvas.\n  // @param {element} container Element onto which to append the canvas.\n  //\n  // Requiring a container is a little iffy, but unfortunately canvas\n  // operations don't work unless the canvas is attached to the DOM.\n\n  function Canvas(cls, container) {\n    var element = container.children('.' + cls)[0];\n\n    if (element == null) {\n      element = document.createElement('canvas');\n      element.className = cls;\n\n      $(element)\n        .css({ direction: 'ltr', position: 'absolute', left: 0, top: 0 })\n        .appendTo(container);\n\n      // If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas\n\n      if (!element.getContext) {\n        if (window.G_vmlCanvasManager) {\n          element = window.G_vmlCanvasManager.initElement(element);\n        } else {\n          throw new Error(\n            \"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\"\n          );\n        }\n      }\n    }\n\n    this.element = element;\n\n    var context = (this.context = element.getContext('2d'));\n\n    // Determine the screen's ratio of physical to device-independent\n    // pixels.  This is the ratio between the canvas width that the browser\n    // advertises and the number of pixels actually present in that space.\n\n    // The iPhone 4, for example, has a device-independent width of 320px,\n    // but its screen is actually 640px wide.  It therefore has a pixel\n    // ratio of 2, while most normal devices have a ratio of 1.\n\n    let devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio =\n        context.webkitBackingStorePixelRatio ||\n        context.mozBackingStorePixelRatio ||\n        context.msBackingStorePixelRatio ||\n        context.oBackingStorePixelRatio ||\n        context.backingStorePixelRatio ||\n        1;\n\n    this.pixelRatio = devicePixelRatio / backingStoreRatio;\n\n    // Size the canvas to match the internal dimensions of its container\n\n    this.resize(container.width(), container.height());\n\n    // Collection of HTML div layers for text overlaid onto the canvas\n\n    this.textContainer = null;\n    this.text = {};\n\n    // Cache of text fragments and metrics, so we can avoid expensively\n    // re-calculating them when the plot is re-rendered in a loop.\n\n    this._textCache = {};\n    this._textSizeCache = window.flotTextSizeCache = window.flotTextSizeCache || {};\n  }\n\n  // Resizes the canvas to the given dimensions.\n  //\n  // @param {number} width New width of the canvas, in pixels.\n  // @param {number} width New height of the canvas, in pixels.\n\n  Canvas.prototype.resize = function(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error('Invalid dimensions for plot, width = ' + width + ', height = ' + height);\n    }\n\n    let element = this.element,\n      context = this.context,\n      pixelRatio = this.pixelRatio;\n\n    // Resize the canvas, increasing its density based on the display's\n    // pixel ratio; basically giving it more pixels without increasing the\n    // size of its element, to take advantage of the fact that retina\n    // displays have that many more pixels in the same advertised space.\n\n    // Resizing should reset the state (excanvas seems to be buggy though)\n\n    if (this.width != width) {\n      element.width = width * pixelRatio;\n      element.style.width = width + 'px';\n      this.width = width;\n    }\n\n    if (this.height != height) {\n      element.height = height * pixelRatio;\n      element.style.height = height + 'px';\n      this.height = height;\n    }\n\n    // Save the context, so we can reset in case we get replotted.  The\n    // restore ensure that we're really back at the initial state, and\n    // should be safe even if we haven't saved the initial state yet.\n\n    context.restore();\n    context.save();\n\n    // Scale the coordinate space to match the display density; so even though we\n    // may have twice as many pixels, we still want lines and other drawing to\n    // appear at the same size; the extra pixels will just make them crisper.\n\n    context.scale(pixelRatio, pixelRatio);\n  };\n\n  // Clears the entire canvas area, not including any overlaid HTML text\n\n  Canvas.prototype.clear = function() {\n    this.context.clearRect(0, 0, this.width, this.height);\n  };\n\n  // Finishes rendering the canvas, including managing the text overlay.\n\n  Canvas.prototype.render = function() {\n    let cache = this._textCache;\n\n    // For each text layer, add elements marked as active that haven't\n    // already been rendered, and remove those that are no longer active.\n\n    for (let layerKey in cache) {\n      if (hasOwnProperty.call(cache, layerKey)) {\n        let layer = this.getTextLayer(layerKey),\n          layerCache = cache[layerKey];\n\n        layer.hide();\n\n        for (let styleKey in layerCache) {\n          if (hasOwnProperty.call(layerCache, styleKey)) {\n            let styleCache = layerCache[styleKey];\n            for (let key in styleCache) {\n              if (hasOwnProperty.call(styleCache, key)) {\n                let positions = styleCache[key].positions;\n\n                for (var i = 0, position; (position = positions[i]); i++) {\n                  if (position.active) {\n                    if (!position.rendered) {\n                      layer.append(position.element);\n                      position.rendered = true;\n                    }\n                  } else {\n                    positions.splice(i--, 1);\n                    if (position.rendered) {\n                      position.element.detach();\n                    }\n                  }\n                }\n\n                if (positions.length == 0) {\n                  delete styleCache[key];\n                }\n              }\n            }\n          }\n        }\n\n        layer.show();\n      }\n    }\n  };\n\n  // Creates (if necessary) and returns the text overlay container.\n  //\n  // @param {string} classes String of space-separated CSS classes used to\n  //     uniquely identify the text layer.\n  // @return {object} The jQuery-wrapped text-layer div.\n\n  Canvas.prototype.getTextLayer = function(classes) {\n    let layer = this.text[classes];\n\n    // Create the text layer if it doesn't exist\n\n    if (layer == null) {\n      // Create the text layer container, if it doesn't exist\n\n      if (this.textContainer == null) {\n        this.textContainer = $(\"<div class='flot-text flot-temp-elem'></div>\")\n          .css({\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            bottom: 0,\n            right: 0,\n            'font-size': 'smaller',\n            color: '#545454',\n          })\n          .insertAfter(this.element);\n      }\n\n      layer = this.text[classes] = $('<div></div>')\n        .addClass(classes)\n        .css({\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          bottom: 0,\n          right: 0,\n        })\n        .appendTo(this.textContainer);\n    }\n\n    return layer;\n  };\n\n  // Creates (if necessary) and returns a text info object.\n  //\n  // The object looks like this:\n  //\n  // {\n  //     width: Width of the text's wrapper div.\n  //     height: Height of the text's wrapper div.\n  //     element: The jQuery-wrapped HTML div containing the text.\n  //     positions: Array of positions at which this text is drawn.\n  // }\n  //\n  // The positions array contains objects that look like this:\n  //\n  // {\n  //     active: Flag indicating whether the text should be visible.\n  //     rendered: Flag indicating whether the text is currently visible.\n  //     element: The jQuery-wrapped HTML div containing the text.\n  //     x: X coordinate at which to draw the text.\n  //     y: Y coordinate at which to draw the text.\n  // }\n  //\n  // Each position after the first receives a clone of the original element.\n  //\n  // The idea is that that the width, height, and general 'identity' of the\n  // text is constant no matter where it is placed; the placements are a\n  // secondary property.\n  //\n  // Canvas maintains a cache of recently-used text info objects; getTextInfo\n  // either returns the cached element or creates a new entry.\n  //\n  // @param {string} layer A string of space-separated CSS classes uniquely\n  //     identifying the layer containing this text.\n  // @param {string} text Text string to retrieve info for.\n  // @param {(string|object)=} font Either a string of space-separated CSS\n  //     classes or a font-spec object, defining the text's font and style.\n  // @param {number=} angle Angle at which to rotate the text, in degrees.\n  //     Angle is currently unused, it will be implemented in the future.\n  // @param {number=} width Maximum width of the text before it wraps.\n  // @return {object} a text info object.\n\n  Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {\n    let textStyle, layerCache, styleCache, info;\n\n    // Cast the value to a string, in case we were given a number or such\n\n    text = '' + text;\n\n    // If the font is a font-spec object, generate a CSS font definition\n\n    if (typeof font === 'object') {\n      textStyle =\n        font.style +\n        ' ' +\n        font.variant +\n        ' ' +\n        font.weight +\n        ' ' +\n        font.size +\n        'px/' +\n        font.lineHeight +\n        'px ' +\n        font.family;\n    } else {\n      textStyle = font;\n    }\n\n    // Retrieve (or create) the cache for the text's layer and styles\n\n    layerCache = this._textCache[layer];\n\n    if (layerCache == null) {\n      layerCache = this._textCache[layer] = {};\n    }\n\n    styleCache = layerCache[textStyle];\n\n    if (styleCache == null) {\n      styleCache = layerCache[textStyle] = {};\n    }\n\n    info = styleCache[text];\n\n    // If we can't find a matching element in our cache, create a new one\n\n    if (info == null) {\n      var element = $('<div></div>')\n        .html(text)\n        .css({\n          position: 'absolute',\n          'max-width': width,\n          top: -9999,\n        })\n        .appendTo(this.getTextLayer(layer));\n\n      if (typeof font === 'object') {\n        element.css({\n          font: textStyle,\n          color: font.color,\n        });\n      } else if (typeof font === 'string') {\n        element.addClass(font);\n      }\n\n      info = styleCache[text] = { element: element, positions: [] };\n\n      let size = this._textSizeCache[text];\n      if (size) {\n        info.width = size.width;\n        info.height = size.height;\n      } else {\n        info.width = element.outerWidth(true);\n        info.height = element.outerHeight(true);\n        this._textSizeCache[text] = { width: info.width, height: info.height };\n      }\n      element.detach();\n    }\n\n    return info;\n  };\n\n  // Adds a text string to the canvas text overlay.\n  //\n  // The text isn't drawn immediately; it is marked as rendering, which will\n  // result in its addition to the canvas on the next render pass.\n  //\n  // @param {string} layer A string of space-separated CSS classes uniquely\n  //     identifying the layer containing this text.\n  // @param {number} x X coordinate at which to draw the text.\n  // @param {number} y Y coordinate at which to draw the text.\n  // @param {string} text Text string to draw.\n  // @param {(string|object)=} font Either a string of space-separated CSS\n  //     classes or a font-spec object, defining the text's font and style.\n  // @param {number=} angle Angle at which to rotate the text, in degrees.\n  //     Angle is currently unused, it will be implemented in the future.\n  // @param {number=} width Maximum width of the text before it wraps.\n  // @param {string=} halign Horizontal alignment of the text; either \"left\",\n  //     \"center\" or \"right\".\n  // @param {string=} valign Vertical alignment of the text; either \"top\",\n  //     \"middle\" or \"bottom\".\n\n  Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {\n    let info = this.getTextInfo(layer, text, font, angle, width),\n      positions = info.positions;\n\n    // Tweak the div's position to match the text's alignment\n\n    if (halign == 'center') {\n      x -= info.width / 2;\n    } else if (halign == 'right') {\n      x -= info.width;\n    }\n\n    if (valign == 'middle') {\n      y -= info.height / 2;\n    } else if (valign == 'bottom') {\n      y -= info.height;\n    }\n\n    // Determine whether this text already exists at this position.\n    // If so, mark it for inclusion in the next render pass.\n\n    for (var i = 0, position; (position = positions[i]); i++) {\n      if (position.x == x && position.y == y) {\n        position.active = true;\n        return;\n      }\n    }\n\n    // If the text doesn't exist at this position, create a new entry\n\n    // For the very first position we'll re-use the original element,\n    // while for subsequent ones we'll clone it.\n\n    position = {\n      active: true,\n      rendered: false,\n      element: positions.length ? info.element.clone() : info.element,\n      x: x,\n      y: y,\n    };\n\n    positions.push(position);\n\n    // Move the element to its final position within the container\n\n    position.element.css({\n      top: Math.round(y),\n      left: Math.round(x),\n      'text-align': halign, // In case the text wraps\n    });\n  };\n\n  // Removes one or more text strings from the canvas text overlay.\n  //\n  // If no parameters are given, all text within the layer is removed.\n  //\n  // Note that the text is not immediately removed; it is simply marked as\n  // inactive, which will result in its removal on the next render pass.\n  // This avoids the performance penalty for 'clear and redraw' behavior,\n  // where we potentially get rid of all text on a layer, but will likely\n  // add back most or all of it later, as when redrawing axes, for example.\n  //\n  // @param {string} layer A string of space-separated CSS classes uniquely\n  //     identifying the layer containing this text.\n  // @param {number=} x X coordinate of the text.\n  // @param {number=} y Y coordinate of the text.\n  // @param {string=} text Text string to remove.\n  // @param {(string|object)=} font Either a string of space-separated CSS\n  //     classes or a font-spec object, defining the text's font and style.\n  // @param {number=} angle Angle at which the text is rotated, in degrees.\n  //     Angle is currently unused, it will be implemented in the future.\n\n  Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {\n    if (text == null) {\n      let layerCache = this._textCache[layer];\n      if (layerCache != null) {\n        for (let styleKey in layerCache) {\n          if (hasOwnProperty.call(layerCache, styleKey)) {\n            let styleCache = layerCache[styleKey];\n            for (let key in styleCache) {\n              if (hasOwnProperty.call(styleCache, key)) {\n                var positions = styleCache[key].positions;\n                for (var i = 0, position; (position = positions[i]); i++) {\n                  position.active = false;\n                }\n              }\n            }\n          }\n        }\n      }\n    } else {\n      var positions = this.getTextInfo(layer, text, font, angle).positions;\n      for (var i = 0, position; (position = positions[i]); i++) {\n        if (position.x == x && position.y == y) {\n          position.active = false;\n        }\n      }\n    }\n  };\n\n  ///////////////////////////////////////////////////////////////////////////\n  // The top-level container for the entire plot.\n\n  function Plot(placeholder, data_, options_, plugins) {\n    // data is on the form:\n    //   [ series1, series2 ... ]\n    // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\n    // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\n\n    let series = [],\n      options = {\n        // the color theme used for graphs\n        colors: ['#edc240', '#afd8f8', '#cb4b4b', '#4da74d', '#9440ed'],\n        legend: {\n          show: true,\n          noColumns: 1, // number of colums in legend table\n          labelFormatter: null, // fn: string -> string\n          labelBoxBorderColor: '#ccc', // border color for the little label boxes\n          container: null, // container (as jQuery object) to put legend in, null means default on top of graph\n          position: 'ne', // position of default legend container within plot\n          margin: 5, // distance from grid edge to default legend container within plot\n          backgroundColor: null, // null means auto-detect\n          backgroundOpacity: 0.85, // set to 0 to avoid background\n          sorted: null, // default to no legend sorting\n        },\n        xaxis: {\n          show: null, // null = auto-detect, true = always, false = never\n          position: 'bottom', // or \"top\"\n          mode: null, // null or \"time\"\n          font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: \"italic\", weight: \"bold\", family: \"sans-serif\", variant: \"small-caps\" }\n          color: null, // base color, labels, ticks\n          tickColor: null, // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\n          transform: null, // null or f: number -> number to transform axis\n          inverseTransform: null, // if transform is set, this should be the inverse function\n          min: null, // min. value to show, null means set automatically\n          max: null, // max. value to show, null means set automatically\n          autoscaleMargin: null, // margin in % to add if auto-setting min/max\n          ticks: null, // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\n          tickFormatter: null, // fn: number -> string\n          labelWidth: null, // size of tick labels in pixels\n          labelHeight: null,\n          reserveSpace: null, // whether to reserve space even if axis isn't shown\n          tickLength: null, // size in pixels of ticks, or \"full\" for whole line\n          alignTicksWithAxis: null, // axis number or null for no sync\n          tickDecimals: null, // no. of decimals, null means auto\n          tickSize: null, // number or [number, \"unit\"]\n          minTickSize: null, // number or [number, \"unit\"]\n        },\n        yaxis: {\n          autoscaleMargin: 0.02,\n          position: 'left', // or \"right\"\n        },\n        xaxes: [],\n        yaxes: [],\n        series: {\n          points: {\n            show: false,\n            radius: 3,\n            lineWidth: 2, // in pixels\n            fill: true,\n            fillColor: '#ffffff',\n            symbol: 'circle', // or callback\n          },\n          lines: {\n            // we don't put in show: false so we can see\n            // whether lines were actively disabled\n            lineWidth: 2, // in pixels\n            fill: false,\n            fillColor: null,\n            steps: false,\n            // Omit 'zero', so we can later default its value to\n            // match that of the 'fill' option.\n          },\n          bars: {\n            show: false,\n            lineWidth: 2, // in pixels\n            barWidth: 1, // in units of the x axis\n            fill: true,\n            fillColor: null,\n            align: 'left', // \"left\", \"right\", or \"center\"\n            horizontal: false,\n            zero: true,\n          },\n          shadowSize: 3,\n          highlightColor: null,\n        },\n        grid: {\n          show: true,\n          aboveData: false,\n          color: '#545454', // primary color used for outline and labels\n          backgroundColor: null, // null for transparent, else color\n          borderColor: null, // set if different from the grid color\n          tickColor: null, // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\n          margin: 0, // distance from the canvas edge to the grid\n          labelMargin: 5, // in pixels\n          eventSectionHeight: 0, // space for event section\n          axisMargin: 8, // in pixels\n          borderWidth: 2, // in pixels\n          minBorderMargin: null, // in pixels, null means taken from points radius\n          markings: null, // array of ranges or fn: axes -> array of ranges\n          markingsColor: '#f4f4f4',\n          markingsLineWidth: 2,\n          // interactive stuff\n          clickable: false,\n          hoverable: false,\n          autoHighlight: true, // highlight in case mouse is near\n          mouseActiveRadius: 10, // how far the mouse can be away to activate an item\n        },\n        interaction: {\n          redrawOverlayInterval: 1000 / 60, // time between updates, -1 means in same flow\n        },\n        hooks: {},\n      },\n      surface = null, // the canvas for the plot itself\n      overlay = null, // canvas for interactive stuff on top of plot\n      eventHolder = null, // jQuery object that events should be bound to\n      ctx = null,\n      octx = null,\n      xaxes = [],\n      yaxes = [],\n      plotOffset = { left: 0, right: 0, top: 0, bottom: 0 },\n      plotWidth = 0,\n      plotHeight = 0,\n      hooks = {\n        processOptions: [],\n        processRawData: [],\n        processDatapoints: [],\n        processOffset: [],\n        processRange: [],\n        drawBackground: [],\n        drawSeries: [],\n        draw: [],\n        bindEvents: [],\n        drawOverlay: [],\n        shutdown: [],\n      },\n      plot = this;\n\n    // public functions\n    plot.setData = setData;\n    plot.setupGrid = setupGrid;\n    plot.draw = draw;\n    plot.getPlaceholder = function() {\n      return placeholder;\n    };\n    plot.getCanvas = function() {\n      return surface.element;\n    };\n    plot.getPlotOffset = function() {\n      return plotOffset;\n    };\n    plot.width = function() {\n      return plotWidth;\n    };\n    plot.height = function() {\n      return plotHeight;\n    };\n    plot.offset = function() {\n      let o = eventHolder.offset();\n      o.left += plotOffset.left;\n      o.top += plotOffset.top;\n      return o;\n    };\n    plot.getData = function() {\n      return series;\n    };\n    plot.getAxes = function() {\n      var res = {};\n      $.each(xaxes.concat(yaxes), function(_, axis) {\n        if (axis) res[axis.direction + (axis.n != 1 ? axis.n : '') + 'axis'] = axis;\n      });\n      return res;\n    };\n    plot.getXAxes = function() {\n      return xaxes;\n    };\n    plot.getYAxes = function() {\n      return yaxes;\n    };\n    plot.c2p = canvasToAxisCoords;\n    plot.p2c = axisToCanvasCoords;\n    plot.getOptions = function() {\n      return options;\n    };\n    plot.highlight = highlight;\n    plot.unhighlight = unhighlight;\n    plot.triggerRedrawOverlay = triggerRedrawOverlay;\n    plot.pointOffset = function(point) {\n      return {\n        left: parseInt(xaxes[axisNumber(point, 'x') - 1].p2c(+point.x) + plotOffset.left, 10),\n        top: parseInt(yaxes[axisNumber(point, 'y') - 1].p2c(+point.y) + plotOffset.top, 10),\n      };\n    };\n    plot.shutdown = shutdown;\n    plot.destroy = function() {\n      shutdown();\n      placeholder.removeData('plot').empty();\n\n      series = [];\n      options = null;\n      surface = null;\n      overlay = null;\n      eventHolder = null;\n      ctx = null;\n      octx = null;\n      xaxes = [];\n      yaxes = [];\n      hooks = null;\n      highlights = [];\n      plot = null;\n    };\n    plot.resize = function() {\n      let width = placeholder.width(),\n        height = placeholder.height();\n      surface.resize(width, height);\n      overlay.resize(width, height);\n    };\n\n    // public attributes\n    plot.hooks = hooks;\n\n    // initialize\n    initPlugins(plot);\n    parseOptions(options_);\n    setupCanvases();\n    setData(data_);\n    setupGrid();\n    draw();\n    bindEvents();\n\n    function executeHooks(hook, args) {\n      args = [plot].concat(args);\n      for (var i = 0; i < hook.length; ++i) hook[i].apply(this, args);\n    }\n\n    function initPlugins() {\n      // References to key classes, allowing plugins to modify them\n\n      let classes = {\n        Canvas: Canvas,\n      };\n\n      for (let i = 0; i < plugins.length; ++i) {\n        let p = plugins[i];\n        p.init(plot, classes);\n        if (p.options) $.extend(true, options, p.options);\n      }\n    }\n\n    function parseOptions(opts) {\n      $.extend(true, options, opts);\n\n      // $.extend merges arrays, rather than replacing them.  When less\n      // colors are provided than the size of the default palette, we\n      // end up with those colors plus the remaining defaults, which is\n      // not expected behavior; avoid it by replacing them here.\n\n      if (opts && opts.colors) {\n        options.colors = opts.colors;\n      }\n\n      if (options.xaxis.color == null)\n        options.xaxis.color = $.color\n          .parse(options.grid.color)\n          .scale('a', 0.22)\n          .toString();\n      if (options.yaxis.color == null)\n        options.yaxis.color = $.color\n          .parse(options.grid.color)\n          .scale('a', 0.22)\n          .toString();\n\n      if (options.xaxis.tickColor == null)\n        // grid.tickColor for back-compatibility\n        options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n      if (options.yaxis.tickColor == null)\n        // grid.tickColor for back-compatibility\n        options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n\n      if (options.grid.borderColor == null) options.grid.borderColor = options.grid.color;\n      if (options.grid.tickColor == null)\n        options.grid.tickColor = $.color\n          .parse(options.grid.color)\n          .scale('a', 0.22)\n          .toString();\n\n      // Fill in defaults for axis options, including any unspecified\n      // font-spec fields, if a font-spec was provided.\n\n      // If no x/y axis options were provided, create one of each anyway,\n      // since the rest of the code assumes that they exist.\n\n      var i,\n        axisOptions,\n        axisCount,\n        fontSize = placeholder.css('font-size'),\n        fontSizeDefault = fontSize ? +fontSize.replace('px', '') : 13,\n        fontDefaults = {\n          style: placeholder.css('font-style'),\n          size: Math.round(0.8 * fontSizeDefault),\n          variant: placeholder.css('font-variant'),\n          weight: placeholder.css('font-weight'),\n          family: placeholder.css('font-family'),\n        };\n\n      axisCount = options.xaxes.length || 1;\n      for (i = 0; i < axisCount; ++i) {\n        axisOptions = options.xaxes[i];\n        if (axisOptions && !axisOptions.tickColor) {\n          axisOptions.tickColor = axisOptions.color;\n        }\n\n        axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\n        options.xaxes[i] = axisOptions;\n\n        if (axisOptions.font) {\n          axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n          if (!axisOptions.font.color) {\n            axisOptions.font.color = axisOptions.color;\n          }\n          if (!axisOptions.font.lineHeight) {\n            axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n          }\n        }\n      }\n\n      axisCount = options.yaxes.length || 1;\n      for (i = 0; i < axisCount; ++i) {\n        axisOptions = options.yaxes[i];\n        if (axisOptions && !axisOptions.tickColor) {\n          axisOptions.tickColor = axisOptions.color;\n        }\n\n        axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\n        options.yaxes[i] = axisOptions;\n\n        if (axisOptions.font) {\n          axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n          if (!axisOptions.font.color) {\n            axisOptions.font.color = axisOptions.color;\n          }\n          if (!axisOptions.font.lineHeight) {\n            axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n          }\n        }\n      }\n\n      // backwards compatibility, to be removed in future\n      if (options.xaxis.noTicks && options.xaxis.ticks == null) options.xaxis.ticks = options.xaxis.noTicks;\n      if (options.yaxis.noTicks && options.yaxis.ticks == null) options.yaxis.ticks = options.yaxis.noTicks;\n      if (options.x2axis) {\n        options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\n        options.xaxes[1].position = 'top';\n        // Override the inherit to allow the axis to auto-scale\n        if (options.x2axis.min == null) {\n          options.xaxes[1].min = null;\n        }\n        if (options.x2axis.max == null) {\n          options.xaxes[1].max = null;\n        }\n      }\n      if (options.y2axis) {\n        options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\n        options.yaxes[1].position = 'right';\n        // Override the inherit to allow the axis to auto-scale\n        if (options.y2axis.min == null) {\n          options.yaxes[1].min = null;\n        }\n        if (options.y2axis.max == null) {\n          options.yaxes[1].max = null;\n        }\n      }\n      if (options.grid.coloredAreas) options.grid.markings = options.grid.coloredAreas;\n      if (options.grid.coloredAreasColor) options.grid.markingsColor = options.grid.coloredAreasColor;\n      if (options.lines) $.extend(true, options.series.lines, options.lines);\n      if (options.points) $.extend(true, options.series.points, options.points);\n      if (options.bars) $.extend(true, options.series.bars, options.bars);\n      if (options.shadowSize != null) options.series.shadowSize = options.shadowSize;\n      if (options.highlightColor != null) options.series.highlightColor = options.highlightColor;\n\n      // save options on axes for future reference\n      for (i = 0; i < options.xaxes.length; ++i) getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n      for (i = 0; i < options.yaxes.length; ++i) getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n\n      // add hooks from options\n      for (var n in hooks) if (options.hooks[n] && options.hooks[n].length) hooks[n] = hooks[n].concat(options.hooks[n]);\n\n      executeHooks(hooks.processOptions, [options]);\n    }\n\n    function setData(d) {\n      series = parseData(d);\n      fillInSeriesOptions();\n      processData();\n    }\n\n    function parseData(d) {\n      let res = [];\n      for (let i = 0; i < d.length; ++i) {\n        let s = $.extend(true, {}, options.series);\n\n        if (d[i].data != null) {\n          s.data = d[i].data; // move the data instead of deep-copy\n          delete d[i].data;\n\n          $.extend(true, s, d[i]);\n\n          d[i].data = s.data;\n        } else s.data = d[i];\n        res.push(s);\n      }\n\n      return res;\n    }\n\n    function axisNumber(obj, coord) {\n      var a = obj[coord + 'axis'];\n      if (typeof a == 'object')\n        // if we got a real axis, extract number\n        a = a.n;\n      if (typeof a != 'number') a = 1; // default to first axis\n      return a;\n    }\n\n    function allAxes() {\n      // return flat array without annoying null entries\n      return $.grep(xaxes.concat(yaxes), function(a) {\n        return a;\n      });\n    }\n\n    function canvasToAxisCoords(pos) {\n      // return an object with x/y corresponding to all used axes\n      var res = {},\n        i,\n        axis;\n      for (i = 0; i < xaxes.length; ++i) {\n        axis = xaxes[i];\n        if (axis) res['x' + axis.n] = axis.c2p(pos.left);\n      }\n\n      for (i = 0; i < yaxes.length; ++i) {\n        axis = yaxes[i];\n        if (axis) res['y' + axis.n] = axis.c2p(pos.top);\n      }\n\n      if (res.x1 !== undefined) res.x = res.x1;\n      if (res.y1 !== undefined) res.y = res.y1;\n\n      return res;\n    }\n\n    function axisToCanvasCoords(pos) {\n      // get canvas coords from the first pair of x/y found in pos\n      var res = {},\n        i,\n        axis,\n        key;\n\n      for (i = 0; i < xaxes.length; ++i) {\n        axis = xaxes[i];\n        if (axis && axis.used) {\n          key = 'x' + axis.n;\n          if (pos[key] == null && axis.n == 1) key = 'x';\n\n          if (pos[key] != null) {\n            res.left = axis.p2c(pos[key]);\n            break;\n          }\n        }\n      }\n\n      for (i = 0; i < yaxes.length; ++i) {\n        axis = yaxes[i];\n        if (axis && axis.used) {\n          key = 'y' + axis.n;\n          if (pos[key] == null && axis.n == 1) key = 'y';\n\n          if (pos[key] != null) {\n            res.top = axis.p2c(pos[key]);\n            break;\n          }\n        }\n      }\n\n      return res;\n    }\n\n    function getOrCreateAxis(axes, number) {\n      if (!axes[number - 1])\n        axes[number - 1] = {\n          n: number, // save the number for future reference\n          direction: axes == xaxes ? 'x' : 'y',\n          options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis),\n        };\n\n      return axes[number - 1];\n    }\n\n    function fillInSeriesOptions() {\n      var neededColors = series.length,\n        maxIndex = -1,\n        i;\n\n      // Subtract the number of series that already have fixed colors or\n      // color indexes from the number that we still need to generate.\n\n      for (i = 0; i < series.length; ++i) {\n        let sc = series[i].color;\n        if (sc != null) {\n          neededColors--;\n          if (typeof sc == 'number' && sc > maxIndex) {\n            maxIndex = sc;\n          }\n        }\n      }\n\n      // If any of the series have fixed color indexes, then we need to\n      // generate at least as many colors as the highest index.\n\n      if (neededColors <= maxIndex) {\n        neededColors = maxIndex + 1;\n      }\n\n      // Generate all the colors, using first the option colors and then\n      // variations on those colors once they're exhausted.\n\n      var c,\n        colors = [],\n        colorPool = options.colors,\n        colorPoolSize = colorPool.length,\n        variation = 0;\n\n      for (i = 0; i < neededColors; i++) {\n        c = $.color.parse(colorPool[i % colorPoolSize] || '#666');\n\n        // Each time we exhaust the colors in the pool we adjust\n        // a scaling factor used to produce more variations on\n        // those colors. The factor alternates negative/positive\n        // to produce lighter/darker colors.\n\n        // Reset the variation after every few cycles, or else\n        // it will end up producing only white or black colors.\n\n        if (i % colorPoolSize == 0 && i) {\n          if (variation >= 0) {\n            if (variation < 0.5) {\n              variation = -variation - 0.2;\n            } else variation = 0;\n          } else variation = -variation;\n        }\n\n        colors[i] = c.scale('rgb', 1 + variation);\n      }\n\n      // Finalize the series options, filling in their colors\n\n      var colori = 0,\n        s;\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n\n        // assign colors\n        if (s.color == null) {\n          s.color = colors[colori].toString();\n          ++colori;\n        } else if (typeof s.color == 'number') s.color = colors[s.color].toString();\n\n        // turn on lines automatically in case nothing is set\n        if (s.lines.show == null) {\n          var v,\n            show = true;\n          for (v in s)\n            if (s[v] && s[v].show) {\n              show = false;\n              break;\n            }\n          if (show) s.lines.show = true;\n        }\n\n        // If nothing was provided for lines.zero, default it to match\n        // lines.fill, since areas by default should extend to zero.\n\n        if (s.lines.zero == null) {\n          s.lines.zero = !!s.lines.fill;\n        }\n\n        // setup axes\n        s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, 'x'));\n        s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, 'y'));\n      }\n    }\n\n    function processData() {\n      let topSentry = Number.POSITIVE_INFINITY,\n        bottomSentry = Number.NEGATIVE_INFINITY,\n        fakeInfinity = Number.MAX_VALUE,\n        i,\n        j,\n        k,\n        m,\n        s,\n        points,\n        ps,\n        val,\n        f,\n        p,\n        data,\n        format;\n\n      function updateAxis(axis, min, max) {\n        if (min < axis.datamin && min != -fakeInfinity) axis.datamin = min;\n        if (max > axis.datamax && max != fakeInfinity) axis.datamax = max;\n      }\n\n      $.each(allAxes(), function(_, axis) {\n        // init axis\n        axis.datamin = topSentry;\n        axis.datamax = bottomSentry;\n        axis.used = false;\n      });\n\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n        s.datapoints = { points: [] };\n\n        executeHooks(hooks.processRawData, [s, s.data, s.datapoints]);\n      }\n\n      // first pass: clean and copy data\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n\n        data = s.data;\n        format = s.datapoints.format;\n\n        if (!format) {\n          format = [];\n          // find out how to copy\n          format.push({ x: true, number: true, required: true });\n          format.push({ y: true, number: true, required: true });\n\n          if (s.stack || s.bars.show || (s.lines.show && s.lines.fill)) {\n            let autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));\n            format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });\n            if (s.bars.horizontal) {\n              delete format[format.length - 1].y;\n              format[format.length - 1].x = true;\n            }\n          }\n\n          s.datapoints.format = format;\n        }\n\n        if (s.datapoints.pointsize != null) continue; // already filled in\n\n        s.datapoints.pointsize = format.length;\n\n        ps = s.datapoints.pointsize;\n        points = s.datapoints.points;\n\n        let insertSteps = s.lines.show && s.lines.steps;\n        s.xaxis.used = s.yaxis.used = true;\n\n        for (j = k = 0; j < data.length; ++j, k += ps) {\n          p = data[j];\n\n          let nullify = p == null;\n          if (!nullify) {\n            for (m = 0; m < ps; ++m) {\n              val = p[m];\n              f = format[m];\n\n              if (f) {\n                if (f.number && val != null) {\n                  val = +val; // convert to number\n                  if (isNaN(val)) val = null;\n                  else if (val == Infinity) val = fakeInfinity;\n                  else if (val == -Infinity) val = -fakeInfinity;\n                }\n\n                if (val == null) {\n                  if (f.required) nullify = true;\n\n                  if (f.defaultValue != null) val = f.defaultValue;\n                }\n              }\n\n              points[k + m] = val;\n            }\n          }\n\n          if (nullify) {\n            for (m = 0; m < ps; ++m) {\n              val = points[k + m];\n              if (val != null) {\n                f = format[m];\n                // extract min/max info\n                if (f.autoscale !== false) {\n                  if (f.x) {\n                    updateAxis(s.xaxis, val, val);\n                  }\n                  if (f.y) {\n                    updateAxis(s.yaxis, val, val);\n                  }\n                }\n              }\n              points[k + m] = null;\n            }\n          }\n\n          if (insertSteps && k > 0 && (!nullify || points[k - ps] != null)) {\n            // copy the point to make room for a middle point\n            for (m = 0; m < ps; ++m) points[k + ps + m] = points[k + m];\n\n            // middle point has same y\n            points[k + 1] = points[k - ps + 1] || 0;\n\n            // if series has null values, let's give the last !null value a nice step\n            if (nullify) points[k] = p[0];\n\n            // we've added a point, better reflect that\n            k += ps;\n          }\n        }\n      }\n\n      // give the hooks a chance to run\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n        points = s.datapoints.points;\n        ps = s.datapoints.pointsize;\n\n        // grafana\n        if (s.transform === 'negative-Y') {\n          for (j = 0; j < points.length; j += ps) {\n            if (points[j] == null) continue;\n\n            val = points[j + 1];\n            points[j + 1] = -val;\n          }\n        }\n\n        executeHooks(hooks.processDatapoints, [s, s.datapoints]);\n      }\n\n      // second pass: find datamax/datamin for auto-scaling\n      for (i = 0; i < series.length; ++i) {\n        s = series[i];\n        points = s.datapoints.points;\n        ps = s.datapoints.pointsize;\n        format = s.datapoints.format;\n\n        var xmin = topSentry,\n          ymin = topSentry,\n          xmax = bottomSentry,\n          ymax = bottomSentry;\n\n        for (j = 0; j < points.length; j += ps) {\n          if (points[j] == null) continue;\n\n          for (m = 0; m < ps; ++m) {\n            val = points[j + m];\n            f = format[m];\n            if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity) continue;\n\n            if (f.x) {\n              if (val < xmin) xmin = val;\n              if (val > xmax) xmax = val;\n            }\n            if (f.y) {\n              if (val < ymin) ymin = val;\n              if (val > ymax) ymax = val;\n            }\n          }\n        }\n\n        if (s.bars.show) {\n          // make sure we got room for the bar on the dancing floor\n          var delta;\n\n          switch (s.bars.align) {\n            case 'left':\n              delta = 0;\n              break;\n            case 'right':\n              delta = -s.bars.barWidth;\n              break;\n            default:\n              delta = -s.bars.barWidth / 2;\n          }\n\n          if (s.bars.horizontal) {\n            ymin += delta;\n            ymax += delta + s.bars.barWidth;\n          } else {\n            xmin += delta;\n            xmax += delta + s.bars.barWidth;\n          }\n        }\n\n        updateAxis(s.xaxis, xmin, xmax);\n        updateAxis(s.yaxis, ymin, ymax);\n      }\n\n      $.each(allAxes(), function(_, axis) {\n        if (axis.datamin == topSentry) axis.datamin = null;\n        if (axis.datamax == bottomSentry) axis.datamax = null;\n      });\n    }\n\n    function setupCanvases() {\n      // Make sure the placeholder is clear of everything except canvases\n      // from a previous plot in this container that we'll try to re-use.\n\n      placeholder.find('.flot-temp-elem').remove();\n\n      if (placeholder.css('position') == 'static') placeholder.css('position', 'relative'); // for positioning labels and overlay\n\n      surface = new Canvas('flot-base', placeholder);\n      overlay = new Canvas('flot-overlay', placeholder); // overlay canvas for interactive features\n\n      ctx = surface.context;\n      octx = overlay.context;\n\n      // define which element we're listening for events on\n      eventHolder = $(overlay.element).unbind();\n\n      // If we're re-using a plot object, shut down the old one\n\n      var existing = placeholder.data('plot');\n\n      if (existing) {\n        existing.shutdown();\n        overlay.clear();\n      }\n\n      // save in case we get replotted\n      placeholder.data('plot', plot);\n    }\n\n    function bindEvents() {\n      // bind events\n      if (options.grid.hoverable) {\n        eventHolder.mousemove(onMouseMove);\n\n        // Use bind, rather than .mouseleave, because we officially\n        // still support jQuery 1.2.6, which doesn't define a shortcut\n        // for mouseenter or mouseleave.  This was a bug/oversight that\n        // was fixed somewhere around 1.3.x.  We can return to using\n        // .mouseleave when we drop support for 1.2.6.\n\n        eventHolder.bind('mouseleave', onMouseLeave);\n      }\n\n      if (options.grid.clickable) eventHolder.click(onClick);\n\n      executeHooks(hooks.bindEvents, [eventHolder]);\n    }\n\n    function shutdown() {\n      if (redrawTimeout) clearTimeout(redrawTimeout);\n\n      eventHolder.unbind('mousemove', onMouseMove);\n      eventHolder.unbind('mouseleave', onMouseLeave);\n      eventHolder.unbind('click', onClick);\n\n      executeHooks(hooks.shutdown, [eventHolder]);\n    }\n\n    function setTransformationHelpers(axis) {\n      // set helper functions on the axis, assumes plot area\n      // has been computed already\n\n      function identity(x) {\n        return x;\n      }\n\n      var s,\n        m,\n        t = axis.options.transform || identity,\n        it = axis.options.inverseTransform;\n\n      // precompute how much the axis is scaling a point\n      // in canvas space\n      if (axis.direction == 'x') {\n        s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n        m = Math.min(t(axis.max), t(axis.min));\n      } else {\n        s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n        s = -s;\n        m = Math.max(t(axis.max), t(axis.min));\n      }\n\n      // data point to canvas coordinate\n      if (t == identity)\n        // slight optimization\n        axis.p2c = function(p) {\n          return (p - m) * s;\n        };\n      else\n        axis.p2c = function(p) {\n          return (t(p) - m) * s;\n        };\n      // canvas coordinate to data point\n      if (!it)\n        axis.c2p = function(c) {\n          return m + c / s;\n        };\n      else\n        axis.c2p = function(c) {\n          return it(m + c / s);\n        };\n    }\n\n    function measureTickLabels(axis) {\n      let opts = axis.options,\n        ticks = axis.ticks || [],\n        labelWidth = opts.labelWidth || 0,\n        labelHeight = opts.labelHeight || 0,\n        maxWidth = labelWidth || (axis.direction == 'x' ? Math.floor(surface.width / (ticks.length || 1)) : null),\n        legacyStyles = axis.direction + 'Axis ' + axis.direction + axis.n + 'Axis',\n        layer = 'flot-' + axis.direction + '-axis flot-' + axis.direction + axis.n + '-axis ' + legacyStyles,\n        font = opts.font || 'flot-tick-label tickLabel';\n\n      for (let i = 0; i < ticks.length; ++i) {\n        let t = ticks[i];\n\n        if (!t.label) continue;\n\n        let info = surface.getTextInfo(layer, t.label, font, null, maxWidth);\n\n        /// Grafana fix, add +1 to label width\n        labelWidth = Math.max(labelWidth, info.width + 1);\n        labelHeight = Math.max(labelHeight, info.height);\n      }\n\n      axis.labelWidth = opts.labelWidth || labelWidth;\n      axis.labelHeight = opts.labelHeight || labelHeight;\n    }\n\n    function allocateAxisBoxFirstPhase(axis) {\n      // find the bounding box of the axis by looking at label\n      // widths/heights and ticks, make room by diminishing the\n      // plotOffset; this first phase only looks at one\n      // dimension per axis, the other dimension depends on the\n      // other axes so will have to wait\n\n      let lw = axis.labelWidth,\n        lh = axis.labelHeight,\n        pos = axis.options.position,\n        isXAxis = axis.direction === 'x',\n        tickLength = axis.options.tickLength,\n        axisMargin = options.grid.axisMargin,\n        padding = options.grid.labelMargin,\n        eventSectionPadding = options.grid.eventSectionHeight,\n        innermost = true,\n        outermost = true,\n        first = true,\n        found = false;\n\n      // Determine the axis's position in its direction and on its side\n\n      $.each(isXAxis ? xaxes : yaxes, function(i, a) {\n        if (a && (a.show || a.reserveSpace)) {\n          if (a === axis) {\n            found = true;\n          } else if (a.options.position === pos) {\n            if (found) {\n              outermost = false;\n            } else {\n              innermost = false;\n            }\n          }\n          if (!found) {\n            first = false;\n          }\n        }\n      });\n\n      // The outermost axis on each side has no margin\n\n      if (outermost) {\n        axisMargin = 0;\n      }\n\n      // The ticks for the first axis in each direction stretch across\n\n      if (tickLength == null) {\n        tickLength = first ? 'full' : 5;\n      }\n\n      if (!isNaN(+tickLength)) padding += +tickLength;\n\n      if (isXAxis) {\n        // Add space for event section\n        lh += padding;\n        lh += eventSectionPadding;\n\n        if (pos == 'bottom') {\n          plotOffset.bottom += lh + axisMargin;\n          axis.box = { top: surface.height - plotOffset.bottom, height: lh };\n        } else {\n          axis.box = { top: plotOffset.top + axisMargin, height: lh };\n          plotOffset.top += lh + axisMargin;\n        }\n      } else {\n        lw += padding;\n\n        if (pos == 'left') {\n          axis.box = { left: plotOffset.left + axisMargin, width: lw };\n          plotOffset.left += lw + axisMargin;\n        } else {\n          plotOffset.right += lw + axisMargin;\n          axis.box = { left: surface.width - plotOffset.right, width: lw };\n        }\n      }\n\n      // save for future reference\n      axis.position = pos;\n      axis.tickLength = tickLength;\n      axis.box.padding = padding;\n      axis.box.eventSectionPadding = eventSectionPadding;\n      axis.innermost = innermost;\n    }\n\n    function allocateAxisBoxSecondPhase(axis) {\n      // now that all axis boxes have been placed in one\n      // dimension, we can set the remaining dimension coordinates\n      if (axis.direction == 'x') {\n        axis.box.left = plotOffset.left - axis.labelWidth / 2;\n        axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\n      } else {\n        axis.box.top = plotOffset.top - axis.labelHeight / 2;\n        axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\n      }\n    }\n\n    function adjustLayoutForThingsStickingOut() {\n      // possibly adjust plot offset to ensure everything stays\n      // inside the canvas and isn't clipped off\n\n      let minMargin = options.grid.minBorderMargin,\n        i;\n\n      // check stuff from the plot (FIXME: this should just read\n      // a value from the series, otherwise it's impossible to\n      // customize)\n      if (minMargin == null) {\n        minMargin = 0;\n        for (i = 0; i < series.length; ++i)\n          minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth / 2));\n      }\n\n      let margins = {\n        left: minMargin,\n        right: minMargin,\n        top: minMargin,\n        bottom: minMargin,\n      };\n\n      // check axis labels, note we don't check the actual\n      // labels but instead use the overall width/height to not\n      // jump as much around with replots\n      $.each(allAxes(), function(_, axis) {\n        if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n          if (axis.direction === 'x') {\n            margins.left = Math.max(margins.left, axis.labelWidth / 2);\n            margins.right = Math.max(margins.right, axis.labelWidth / 2);\n          } else {\n            margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n            margins.top = Math.max(margins.top, axis.labelHeight / 2);\n          }\n        }\n      });\n\n      plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n      plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n      plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n      plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\n    }\n\n    function setupGrid() {\n      var i,\n        axes = allAxes(),\n        showGrid = options.grid.show;\n\n      // Initialize the plot's offset from the edge of the canvas\n\n      for (var a in plotOffset) {\n        let margin = options.grid.margin || 0;\n        plotOffset[a] = typeof margin == 'number' ? margin : margin[a] || 0;\n      }\n\n      executeHooks(hooks.processOffset, [plotOffset]);\n\n      // If the grid is visible, add its border width to the offset\n\n      for (var a in plotOffset) {\n        if (typeof options.grid.borderWidth == 'object') {\n          plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\n        } else {\n          plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\n        }\n      }\n\n      $.each(axes, function(_, axis) {\n        let axisOpts = axis.options;\n        axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\n        axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\n        setRange(axis);\n      });\n\n      executeHooks(hooks.processRange, []);\n\n      if (showGrid) {\n        var allocatedAxes = $.grep(axes, function(axis) {\n          return axis.show || axis.reserveSpace;\n        });\n\n        let snaped = false;\n        for (var i = 0; i < 2; i++) {\n          $.each(allocatedAxes, function(_, axis) {\n            // make the ticks\n            setupTickGeneration(axis);\n            setTicks(axis);\n            snaped = snapRangeToTicks(axis, axis.ticks) || snaped;\n            // find labelWidth/Height for axis\n            measureTickLabels(axis);\n          });\n\n          if (snaped && hooks.processRange.length > 0) {\n            executeHooks(hooks.processRange, []);\n            snaped = false;\n          } else {\n            break;\n          }\n        }\n\n        // with all dimensions calculated, we can compute the\n        // axis bounding boxes, start from the outside\n        // (reverse order)\n        for (i = allocatedAxes.length - 1; i >= 0; --i) allocateAxisBoxFirstPhase(allocatedAxes[i]);\n\n        // make sure we've got enough space for things that\n        // might stick out\n        adjustLayoutForThingsStickingOut();\n\n        $.each(allocatedAxes, function(_, axis) {\n          allocateAxisBoxSecondPhase(axis);\n        });\n      }\n\n      plotWidth = surface.width - plotOffset.left - plotOffset.right;\n      plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n      // now we got the proper plot dimensions, we can compute the scaling\n      $.each(axes, function(_, axis) {\n        setTransformationHelpers(axis);\n      });\n\n      if (showGrid) {\n        drawAxisLabels();\n      }\n\n      insertLegend();\n    }\n\n    function setRange(axis) {\n      let opts = axis.options,\n        min = +(opts.min != null ? opts.min : axis.datamin),\n        max = +(opts.max != null ? opts.max : axis.datamax),\n        delta = max - min;\n\n      if (delta == 0.0) {\n        // Grafana fix: wide Y min and max using increased wideFactor\n        // when all series values are the same\n        let wideFactor = 0.25;\n        let widen = Math.abs(max == 0 ? 1 : max * wideFactor);\n\n        if (opts.min == null) {\n          min -= widen;\n        }\n        // always widen max if we couldn't widen min to ensure we\n        // don't fall into min == max which doesn't work\n        if (opts.max == null || opts.min != null) {\n          max += widen;\n        }\n      } else {\n        // consider autoscaling\n        let margin = opts.autoscaleMargin;\n        if (margin != null) {\n          if (opts.min == null) {\n            min -= delta * margin;\n            // make sure we don't go below zero if all values\n            // are positive\n            if (min < 0 && axis.datamin != null && axis.datamin >= 0) min = 0;\n          }\n          if (opts.max == null) {\n            max += delta * margin;\n            if (max > 0 && axis.datamax != null && axis.datamax <= 0) max = 0;\n          }\n        }\n      }\n      axis.min = min;\n      axis.max = max;\n    }\n\n    function setupTickGeneration(axis) {\n      let opts = axis.options;\n\n      // estimate number of ticks\n      let noTicks;\n      if (typeof opts.ticks == 'number' && opts.ticks > 0) noTicks = opts.ticks;\n      // heuristic based on the model a*sqrt(x) fitted to\n      // some data points that seemed reasonable\n      else noTicks = 0.3 * Math.sqrt(axis.direction == 'x' ? surface.width : surface.height);\n\n      let delta = (axis.max - axis.min) / noTicks,\n        dec = -Math.floor(Math.log(delta) / Math.LN10),\n        maxDec = opts.tickDecimals;\n\n      if (maxDec != null && dec > maxDec) {\n        dec = maxDec;\n      }\n\n      let magn = Math.pow(10, -dec),\n        norm = delta / magn, // norm is between 1.0 and 10.0\n        size;\n\n      if (norm < 1.5) {\n        size = 1;\n      } else if (norm < 3) {\n        size = 2;\n        // special case for 2.5, requires an extra decimal\n        if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\n          size = 2.5;\n          ++dec;\n        }\n      } else if (norm < 7.5) {\n        size = 5;\n      } else {\n        size = 10;\n      }\n\n      size *= magn;\n\n      if (opts.minTickSize != null && size < opts.minTickSize) {\n        size = opts.minTickSize;\n      }\n\n      axis.delta = delta;\n      axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\n      axis.tickSize = opts.tickSize || size;\n\n      // grafana addition\n      if (opts.tickDecimals === null || opts.tickDecimals === undefined) {\n        axis.scaledDecimals = axis.tickDecimals + dec;\n      }\n\n      // Time mode was moved to a plug-in in 0.8, and since so many people use it\n      // we'll add an especially friendly reminder to make sure they included it.\n\n      if (opts.mode == 'time' && !axis.tickGenerator) {\n        throw new Error('Time mode requires the flot.time plugin.');\n      }\n\n      // Flot supports base-10 axes; any other mode else is handled by a plug-in,\n      // like flot.time.js.\n\n      if (!axis.tickGenerator) {\n        axis.tickGenerator = function(axis) {\n          let ticks = [],\n            start = floorInBase(axis.min, axis.tickSize),\n            i = 0,\n            v = Number.NaN,\n            prev;\n\n          do {\n            prev = v;\n            v = start + i * axis.tickSize;\n            ticks.push(v);\n            ++i;\n          } while (v < axis.max && v != prev);\n          return ticks;\n        };\n\n        axis.tickFormatter = function(value, axis) {\n          let factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\n          var formatted = '' + Math.round(value * factor) / factor;\n\n          // If tickDecimals was specified, ensure that we have exactly that\n          // much precision; otherwise default to the value's own precision.\n\n          if (axis.tickDecimals != null) {\n            var decimal = formatted.indexOf('.');\n            let precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\n            if (precision < axis.tickDecimals) {\n              return (precision ? formatted : formatted + '.') + ('' + factor).substr(1, axis.tickDecimals - precision);\n            }\n          }\n\n          return formatted;\n        };\n      }\n\n      if ($.isFunction(opts.tickFormatter))\n        axis.tickFormatter = function(v, axis) {\n          return '' + opts.tickFormatter(v, axis);\n        };\n\n      if (opts.alignTicksWithAxis != null) {\n        var otherAxis = (axis.direction == 'x' ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n        if (otherAxis && otherAxis.used && otherAxis != axis) {\n          // consider snapping min/max to outermost nice ticks\n          let niceTicks = axis.tickGenerator(axis);\n          if (niceTicks.length > 0) {\n            if (opts.min == null) axis.min = Math.min(axis.min, niceTicks[0]);\n            if (opts.max == null && niceTicks.length > 1) axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n          }\n\n          axis.tickGenerator = function(axis) {\n            // copy ticks, scaled to this axis\n            var ticks = [],\n              v,\n              i;\n            for (i = 0; i < otherAxis.ticks.length; ++i) {\n              v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n              v = axis.min + v * (axis.max - axis.min);\n              ticks.push(v);\n            }\n            return ticks;\n          };\n\n          // we might need an extra decimal since forced\n          // ticks don't necessarily fit naturally\n          if (!axis.mode && opts.tickDecimals == null) {\n            let extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n              ts = axis.tickGenerator(axis);\n\n            // only proceed if the tick interval rounded\n            // with an extra decimal doesn't give us a\n            // zero at end\n            if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec)))) axis.tickDecimals = extraDec;\n          }\n        }\n      }\n    }\n\n    function setTicks(axis) {\n      var oticks = axis.options.ticks,\n        ticks = [];\n      if (oticks == null || (typeof oticks == 'number' && oticks > 0)) ticks = axis.tickGenerator(axis);\n      else if (oticks) {\n        if ($.isFunction(oticks))\n          // generate the ticks\n          ticks = oticks(axis);\n        else ticks = oticks;\n      }\n\n      // clean up/labelify the supplied ticks, copy them over\n      let i, v;\n      axis.ticks = [];\n      for (i = 0; i < ticks.length; ++i) {\n        let label = null;\n        let t = ticks[i];\n        if (typeof t == 'object') {\n          v = +t[0];\n          if (t.length > 1) label = t[1];\n        } else v = +t;\n        if (label == null) label = axis.tickFormatter(v, axis);\n        if (!isNaN(v)) axis.ticks.push({ v: v, label: label });\n      }\n    }\n\n    function snapRangeToTicks(axis, ticks) {\n      let changed = false;\n      if (axis.options.autoscaleMargin && ticks.length > 0) {\n        // snap to ticks\n        if (axis.options.min == null) {\n          axis.min = Math.min(axis.min, ticks[0].v);\n          changed = true;\n        }\n        if (axis.options.max == null && ticks.length > 1) {\n          axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n          changed = true;\n        }\n      }\n      return changed;\n    }\n\n    function draw() {\n      surface.clear();\n\n      executeHooks(hooks.drawBackground, [ctx]);\n\n      let grid = options.grid;\n\n      // draw background, if any\n      if (grid.show && grid.backgroundColor) drawBackground();\n\n      if (grid.show && !grid.aboveData) {\n        drawGrid();\n      }\n\n      for (let i = 0; i < series.length; ++i) {\n        executeHooks(hooks.drawSeries, [ctx, series[i]]);\n        drawSeries(series[i]);\n      }\n\n      executeHooks(hooks.draw, [ctx]);\n\n      if (grid.show && grid.aboveData) {\n        drawGrid();\n      }\n\n      surface.render();\n\n      // A draw implies that either the axes or data have changed, so we\n      // should probably update the overlay highlights as well.\n\n      triggerRedrawOverlay();\n    }\n\n    function extractRange(ranges, coord) {\n      var axis,\n        from,\n        to,\n        key,\n        axes = allAxes();\n\n      for (let i = 0; i < axes.length; ++i) {\n        axis = axes[i];\n        if (axis.direction == coord) {\n          key = coord + axis.n + 'axis';\n          if (!ranges[key] && axis.n == 1) key = coord + 'axis'; // support x1axis as xaxis\n          if (ranges[key]) {\n            from = ranges[key].from;\n            to = ranges[key].to;\n            break;\n          }\n        }\n      }\n\n      // backwards-compat stuff - to be removed in future\n      if (!ranges[key]) {\n        axis = coord == 'x' ? xaxes[0] : yaxes[0];\n        from = ranges[coord + '1'];\n        to = ranges[coord + '2'];\n      }\n\n      // auto-reverse as an added bonus\n      if (from != null && to != null && from > to) {\n        let tmp = from;\n        from = to;\n        to = tmp;\n      }\n\n      return { from: from, to: to, axis: axis };\n    }\n\n    function drawBackground() {\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top);\n\n      ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, 'rgba(255, 255, 255, 0)');\n      ctx.fillRect(0, 0, plotWidth, plotHeight);\n      ctx.restore();\n    }\n\n    function drawGrid() {\n      let i, axes, bw, bc;\n\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top);\n\n      // draw markings\n      let markings = options.grid.markings;\n      if (markings) {\n        if ($.isFunction(markings)) {\n          axes = plot.getAxes();\n          // xmin etc. is backwards compatibility, to be\n          // removed in the future\n          axes.xmin = axes.xaxis.min;\n          axes.xmax = axes.xaxis.max;\n          axes.ymin = axes.yaxis.min;\n          axes.ymax = axes.yaxis.max;\n\n          markings = markings(axes);\n        }\n\n        for (i = 0; i < markings.length; ++i) {\n          let m = markings[i],\n            xrange = extractRange(m, 'x'),\n            yrange = extractRange(m, 'y');\n\n          // fill in missing\n          if (xrange.from == null) xrange.from = xrange.axis.min;\n          if (xrange.to == null) xrange.to = xrange.axis.max;\n          if (yrange.from == null) yrange.from = yrange.axis.min;\n          if (yrange.to == null) yrange.to = yrange.axis.max;\n\n          // clip\n          if (\n            xrange.to < xrange.axis.min ||\n            xrange.from > xrange.axis.max ||\n            yrange.to < yrange.axis.min ||\n            yrange.from > yrange.axis.max\n          )\n            continue;\n\n          xrange.from = Math.max(xrange.from, xrange.axis.min);\n          xrange.to = Math.min(xrange.to, xrange.axis.max);\n          yrange.from = Math.max(yrange.from, yrange.axis.min);\n          yrange.to = Math.min(yrange.to, yrange.axis.max);\n\n          let xequal = xrange.from === xrange.to,\n            yequal = yrange.from === yrange.to;\n\n          if (xequal && yequal) {\n            continue;\n          }\n\n          // then draw\n          xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n          xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n          yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n          yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n\n          if (xequal || yequal) {\n            let lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n              subPixel = lineWidth % 2 ? 0.5 : 0;\n            ctx.beginPath();\n            ctx.strokeStyle = m.color || options.grid.markingsColor;\n            ctx.lineWidth = lineWidth;\n            if (xequal) {\n              ctx.moveTo(xrange.to + subPixel, yrange.from);\n              ctx.lineTo(xrange.to + subPixel, yrange.to);\n            } else {\n              ctx.moveTo(xrange.from, yrange.to + subPixel);\n              ctx.lineTo(xrange.to, yrange.to + subPixel);\n            }\n            ctx.stroke();\n          } else {\n            ctx.fillStyle = m.color || options.grid.markingsColor;\n            ctx.fillRect(xrange.from, yrange.to, xrange.to - xrange.from, yrange.from - yrange.to);\n          }\n        }\n      }\n\n      // draw the ticks\n      axes = allAxes();\n      bw = options.grid.borderWidth;\n\n      for (let j = 0; j < axes.length; ++j) {\n        var axis = axes[j],\n          box = axis.box,\n          t = axis.tickLength,\n          x,\n          y,\n          xoff,\n          yoff;\n        if (!axis.show || axis.ticks.length == 0) continue;\n\n        ctx.lineWidth = 1;\n\n        // find the edges\n        if (axis.direction == 'x') {\n          x = 0;\n          if (t == 'full') y = axis.position == 'top' ? 0 : plotHeight;\n          else y = box.top - plotOffset.top + (axis.position == 'top' ? box.height : 0);\n        } else {\n          y = 0;\n          if (t == 'full') x = axis.position == 'left' ? 0 : plotWidth;\n          else x = box.left - plotOffset.left + (axis.position == 'left' ? box.width : 0);\n        }\n\n        // draw tick bar\n        if (!axis.innermost) {\n          ctx.strokeStyle = axis.options.color;\n          ctx.beginPath();\n          xoff = yoff = 0;\n          if (axis.direction == 'x') xoff = plotWidth + 1;\n          else yoff = plotHeight + 1;\n\n          if (ctx.lineWidth == 1) {\n            if (axis.direction == 'x') {\n              y = Math.floor(y) + 0.5;\n            } else {\n              x = Math.floor(x) + 0.5;\n            }\n          }\n\n          ctx.moveTo(x, y);\n          ctx.lineTo(x + xoff, y + yoff);\n          ctx.stroke();\n        }\n\n        // draw ticks\n\n        ctx.strokeStyle = axis.options.tickColor;\n\n        ctx.beginPath();\n        for (i = 0; i < axis.ticks.length; ++i) {\n          let v = axis.ticks[i].v;\n\n          xoff = yoff = 0;\n\n          if (\n            isNaN(v) ||\n            v < axis.min ||\n            v > axis.max ||\n            // skip those lying on the axes if we got a border\n            (t == 'full' && ((typeof bw == 'object' && bw[axis.position] > 0) || bw > 0) && (v == axis.min || v == axis.max))\n          )\n            continue;\n\n          if (axis.direction == 'x') {\n            x = axis.p2c(v);\n            yoff = t == 'full' ? -plotHeight : t;\n\n            if (axis.position == 'top') yoff = -yoff;\n          } else {\n            y = axis.p2c(v);\n            xoff = t == 'full' ? -plotWidth : t;\n\n            if (axis.position == 'left') xoff = -xoff;\n          }\n\n          if (ctx.lineWidth == 1) {\n            if (axis.direction == 'x') x = Math.floor(x) + 0.5;\n            else y = Math.floor(y) + 0.5;\n          }\n\n          ctx.moveTo(x, y);\n          ctx.lineTo(x + xoff, y + yoff);\n        }\n\n        ctx.stroke();\n      }\n\n      // draw border\n      if (bw) {\n        // If either borderWidth or borderColor is an object, then draw the border\n        // line by line instead of as one rectangle\n        bc = options.grid.borderColor;\n        if (typeof bw == 'object' || typeof bc == 'object') {\n          if (typeof bw !== 'object') {\n            bw = { top: bw, right: bw, bottom: bw, left: bw };\n          }\n          if (typeof bc !== 'object') {\n            bc = { top: bc, right: bc, bottom: bc, left: bc };\n          }\n\n          if (bw.top > 0) {\n            ctx.strokeStyle = bc.top;\n            ctx.lineWidth = bw.top;\n            ctx.beginPath();\n            ctx.moveTo(0 - bw.left, 0 - bw.top / 2);\n            ctx.lineTo(plotWidth, 0 - bw.top / 2);\n            ctx.stroke();\n          }\n\n          if (bw.right > 0) {\n            ctx.strokeStyle = bc.right;\n            ctx.lineWidth = bw.right;\n            ctx.beginPath();\n            ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n            ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n            ctx.stroke();\n          }\n\n          if (bw.bottom > 0) {\n            ctx.strokeStyle = bc.bottom;\n            ctx.lineWidth = bw.bottom;\n            ctx.beginPath();\n            ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n            ctx.lineTo(0, plotHeight + bw.bottom / 2);\n            ctx.stroke();\n          }\n\n          if (bw.left > 0) {\n            ctx.strokeStyle = bc.left;\n            ctx.lineWidth = bw.left;\n            ctx.beginPath();\n            ctx.moveTo(0 - bw.left / 2, plotHeight + bw.bottom);\n            ctx.lineTo(0 - bw.left / 2, 0);\n            ctx.stroke();\n          }\n        } else {\n          ctx.lineWidth = bw;\n          ctx.strokeStyle = options.grid.borderColor;\n          ctx.strokeRect(-bw / 2, -bw / 2, plotWidth + bw, plotHeight + bw);\n        }\n      }\n\n      ctx.restore();\n    }\n\n    function drawAxisLabels() {\n      $.each(allAxes(), function(_, axis) {\n        let box = axis.box,\n          legacyStyles = axis.direction + 'Axis ' + axis.direction + axis.n + 'Axis',\n          layer = 'flot-' + axis.direction + '-axis flot-' + axis.direction + axis.n + '-axis ' + legacyStyles,\n          font = axis.options.font || 'flot-tick-label tickLabel',\n          tick,\n          x,\n          y,\n          halign,\n          valign;\n\n        // Remove text before checking for axis.show and ticks.length;\n        // otherwise plugins, like flot-tickrotor, that draw their own\n        // tick labels will end up with both theirs and the defaults.\n\n        surface.removeText(layer);\n\n        if (!axis.show || axis.ticks.length == 0) return;\n\n        for (let i = 0; i < axis.ticks.length; ++i) {\n          tick = axis.ticks[i];\n          if (!tick.label || tick.v < axis.min || tick.v > axis.max) continue;\n\n          if (axis.direction == 'x') {\n            halign = 'center';\n            x = plotOffset.left + axis.p2c(tick.v);\n            if (axis.position == 'bottom') {\n              y = box.top + box.padding + box.eventSectionPadding;\n            } else {\n              y = box.top + box.height - box.padding;\n              valign = 'bottom';\n            }\n          } else {\n            valign = 'middle';\n            y = plotOffset.top + axis.p2c(tick.v);\n            if (axis.position == 'left') {\n              x = box.left + box.width - box.padding;\n              halign = 'right';\n            } else {\n              x = box.left + box.padding;\n            }\n          }\n\n          surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\n        }\n      });\n    }\n\n    function drawOrphanedPoints(series) {\n      /* Filters series data for points with no neighbors before or after\n       * and plots single 0.5 radius points for them so that they are displayed.\n       */\n      let abandonedPoints = [];\n      let beforeX = null;\n      let afterX = null;\n      let datapoints = series.datapoints;\n      // find any points with no neighbors before or after\n      let emptyPoints = [];\n      for (let j = 0; j < datapoints.pointsize - 2; j++) {\n        emptyPoints.push(0);\n      }\n      for (let i = 0; i < datapoints.points.length; i += datapoints.pointsize) {\n        var x = datapoints.points[i],\n          y = datapoints.points[i + 1];\n        if (i === datapoints.points.length - datapoints.pointsize) {\n          afterX = null;\n        } else {\n          afterX = datapoints.points[i + datapoints.pointsize];\n        }\n        if (x !== null && y !== null && beforeX === null && afterX === null) {\n          abandonedPoints.push(x);\n          abandonedPoints.push(y);\n          abandonedPoints.push.apply(abandonedPoints, emptyPoints);\n        }\n        beforeX = x;\n      }\n      var olddatapoints = datapoints.points;\n      datapoints.points = abandonedPoints;\n\n      series.points.radius = series.lines.lineWidth / 2;\n      // plot the orphan points with a radius of lineWidth/2\n      drawSeriesPoints(series);\n      // reset old info\n      datapoints.points = olddatapoints;\n    }\n\n    function drawSeries(series) {\n      if (series.lines.show) {\n        drawSeriesLines(series);\n        if (!series.points.show && !series.bars.show) {\n          // not necessary if user wants points displayed for everything\n          drawOrphanedPoints(series);\n        }\n      }\n      if (series.bars.show) drawSeriesBars(series);\n      if (series.points.show) drawSeriesPoints(series);\n    }\n\n    function drawSeriesLines(series) {\n      function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\n        let points = datapoints.points,\n          ps = datapoints.pointsize,\n          prevx = null,\n          prevy = null;\n\n        ctx.beginPath();\n        for (let i = ps; i < points.length; i += ps) {\n          var x1 = points[i - ps],\n            y1 = points[i - ps + 1],\n            x2 = points[i],\n            y2 = points[i + 1];\n\n          if (x1 == null || x2 == null) continue;\n\n          // clip with ymin\n          if (y1 <= y2 && y1 < axisy.min) {\n            if (y2 < axisy.min) continue; // line segment is outside\n            // compute new intersection point\n            x1 = ((axisy.min - y1) / (y2 - y1)) * (x2 - x1) + x1;\n            y1 = axisy.min;\n          } else if (y2 <= y1 && y2 < axisy.min) {\n            if (y1 < axisy.min) continue;\n            x2 = ((axisy.min - y1) / (y2 - y1)) * (x2 - x1) + x1;\n            y2 = axisy.min;\n          }\n\n          // clip with ymax\n          if (y1 >= y2 && y1 > axisy.max) {\n            if (y2 > axisy.max) continue;\n            x1 = ((axisy.max - y1) / (y2 - y1)) * (x2 - x1) + x1;\n            y1 = axisy.max;\n          } else if (y2 >= y1 && y2 > axisy.max) {\n            if (y1 > axisy.max) continue;\n            x2 = ((axisy.max - y1) / (y2 - y1)) * (x2 - x1) + x1;\n            y2 = axisy.max;\n          }\n\n          // clip with xmin\n          if (x1 <= x2 && x1 < axisx.min) {\n            if (x2 < axisx.min) continue;\n            y1 = ((axisx.min - x1) / (x2 - x1)) * (y2 - y1) + y1;\n            x1 = axisx.min;\n          } else if (x2 <= x1 && x2 < axisx.min) {\n            if (x1 < axisx.min) continue;\n            y2 = ((axisx.min - x1) / (x2 - x1)) * (y2 - y1) + y1;\n            x2 = axisx.min;\n          }\n\n          // clip with xmax\n          if (x1 >= x2 && x1 > axisx.max) {\n            if (x2 > axisx.max) continue;\n            y1 = ((axisx.max - x1) / (x2 - x1)) * (y2 - y1) + y1;\n            x1 = axisx.max;\n          } else if (x2 >= x1 && x2 > axisx.max) {\n            if (x1 > axisx.max) continue;\n            y2 = ((axisx.max - x1) / (x2 - x1)) * (y2 - y1) + y1;\n            x2 = axisx.max;\n          }\n\n          if (x1 != prevx || y1 != prevy) ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n\n          prevx = x2;\n          prevy = y2;\n          ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n        }\n        ctx.stroke();\n      }\n\n      function plotLineArea(datapoints, axisx, axisy) {\n        let points = datapoints.points,\n          ps = datapoints.pointsize,\n          bottom = Math.min(Math.max(0, axisy.min), axisy.max),\n          i = 0,\n          areaOpen = false,\n          ypos = 1,\n          segmentStart = 0,\n          segmentEnd = 0;\n\n        // we process each segment in two turns, first forward\n        // direction to sketch out top, then once we hit the\n        // end we go backwards to sketch the bottom\n        while (true) {\n          if (ps > 0 && i > points.length + ps) break;\n\n          i += ps; // ps is negative if going backwards\n\n          let x1 = points[i - ps],\n            y1 = points[i - ps + ypos],\n            x2 = points[i],\n            y2 = points[i + ypos];\n\n          if (areaOpen) {\n            if (ps > 0 && x1 != null && x2 == null) {\n              // at turning point\n              segmentEnd = i;\n              ps = -ps;\n              ypos = 2;\n              continue;\n            }\n\n            if (ps < 0 && i == segmentStart + ps) {\n              // done with the reverse sweep\n              ctx.fill();\n              areaOpen = false;\n              ps = -ps;\n              ypos = 1;\n              i = segmentStart = segmentEnd + ps;\n              continue;\n            }\n          }\n\n          if (x1 == null || x2 == null) continue;\n\n          // clip x values\n\n          // clip with xmin\n          if (x1 <= x2 && x1 < axisx.min) {\n            if (x2 < axisx.min) continue;\n            y1 = ((axisx.min - x1) / (x2 - x1)) * (y2 - y1) + y1;\n            x1 = axisx.min;\n          } else if (x2 <= x1 && x2 < axisx.min) {\n            if (x1 < axisx.min) continue;\n            y2 = ((axisx.min - x1) / (x2 - x1)) * (y2 - y1) + y1;\n            x2 = axisx.min;\n          }\n\n          // clip with xmax\n          if (x1 >= x2 && x1 > axisx.max) {\n            if (x2 > axisx.max) continue;\n            y1 = ((axisx.max - x1) / (x2 - x1)) * (y2 - y1) + y1;\n            x1 = axisx.max;\n          } else if (x2 >= x1 && x2 > axisx.max) {\n            if (x1 > axisx.max) continue;\n            y2 = ((axisx.max - x1) / (x2 - x1)) * (y2 - y1) + y1;\n            x2 = axisx.max;\n          }\n\n          if (!areaOpen) {\n            // open area\n            ctx.beginPath();\n            ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n            areaOpen = true;\n          }\n\n          // now first check the case where both is outside\n          if (y1 >= axisy.max && y2 >= axisy.max) {\n            ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n            ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n            continue;\n          } else if (y1 <= axisy.min && y2 <= axisy.min) {\n            ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n            ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n            continue;\n          }\n\n          // else it's a bit more complicated, there might\n          // be a flat maxed out rectangle first, then a\n          // triangular cutout or reverse; to find these\n          // keep track of the current x values\n          var x1old = x1,\n            x2old = x2;\n\n          // clip the y values, without shortcutting, we\n          // go through all cases in turn\n\n          // clip with ymin\n          if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n            x1 = ((axisy.min - y1) / (y2 - y1)) * (x2 - x1) + x1;\n            y1 = axisy.min;\n          } else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n            x2 = ((axisy.min - y1) / (y2 - y1)) * (x2 - x1) + x1;\n            y2 = axisy.min;\n          }\n\n          // clip with ymax\n          if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n            x1 = ((axisy.max - y1) / (y2 - y1)) * (x2 - x1) + x1;\n            y1 = axisy.max;\n          } else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n            x2 = ((axisy.max - y1) / (y2 - y1)) * (x2 - x1) + x1;\n            y2 = axisy.max;\n          }\n\n          // if the x value was changed we got a rectangle\n          // to fill\n          if (x1 != x1old) {\n            ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\n            // it goes to (x1, y1), but we fill that below\n          }\n\n          // fill triangular section, this sometimes result\n          // in redundant points if (x1, y1) hasn't changed\n          // from previous line to, but we just ignore that\n          ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n          ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n\n          // fill the other rectangle if it's there\n          if (x2 != x2old) {\n            ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n            ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n          }\n        }\n      }\n\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top);\n      ctx.lineJoin = 'round';\n\n      let lw = series.lines.lineWidth,\n        sw = series.shadowSize;\n      // FIXME: consider another form of shadow when filling is turned on\n      if (lw > 0 && sw > 0) {\n        // draw shadow as a thick and thin line with transparency\n        ctx.lineWidth = sw;\n        ctx.strokeStyle = 'rgba(0,0,0,0.1)';\n        // position shadow at angle from the mid of line\n        var angle = Math.PI / 18;\n        plotLine(\n          series.datapoints,\n          Math.sin(angle) * (lw / 2 + sw / 2),\n          Math.cos(angle) * (lw / 2 + sw / 2),\n          series.xaxis,\n          series.yaxis\n        );\n        ctx.lineWidth = sw / 2;\n        plotLine(\n          series.datapoints,\n          Math.sin(angle) * (lw / 2 + sw / 4),\n          Math.cos(angle) * (lw / 2 + sw / 4),\n          series.xaxis,\n          series.yaxis\n        );\n      }\n\n      ctx.lineWidth = lw;\n      ctx.strokeStyle = series.color;\n      let fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\n      if (fillStyle) {\n        ctx.fillStyle = fillStyle;\n        plotLineArea(series.datapoints, series.xaxis, series.yaxis);\n      }\n\n      if (lw > 0) plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\n      ctx.restore();\n    }\n\n    function drawSeriesPoints(series) {\n      function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\n        var points = datapoints.points,\n          ps = datapoints.pointsize;\n\n        for (let i = 0; i < points.length; i += ps) {\n          var x = points[i],\n            y = points[i + 1];\n          if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) continue;\n\n          ctx.beginPath();\n          x = axisx.p2c(x);\n          y = axisy.p2c(y) + offset;\n          if (symbol == 'circle') ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);\n          else symbol(ctx, x, y, radius, shadow);\n          ctx.closePath();\n\n          if (fillStyle) {\n            ctx.fillStyle = fillStyle;\n            ctx.fill();\n          }\n          ctx.stroke();\n        }\n      }\n\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top);\n\n      let lw = series.points.lineWidth,\n        sw = series.shadowSize,\n        radius = series.points.radius,\n        symbol = series.points.symbol;\n\n      // If the user sets the line width to 0, we change it to a very\n      // small value. A line width of 0 seems to force the default of 1.\n      // Doing the conditional here allows the shadow setting to still be\n      // optional even with a lineWidth of 0.\n\n      if (lw == 0) lw = 0.0001;\n\n      if (lw > 0 && sw > 0) {\n        // draw shadow in two steps\n        let w = sw / 2;\n        ctx.lineWidth = w;\n        ctx.strokeStyle = 'rgba(0,0,0,0.1)';\n        plotPoints(series.datapoints, radius, null, w + w / 2, true, series.xaxis, series.yaxis, symbol);\n\n        ctx.strokeStyle = 'rgba(0,0,0,0.2)';\n        plotPoints(series.datapoints, radius, null, w / 2, true, series.xaxis, series.yaxis, symbol);\n      }\n\n      ctx.lineWidth = lw;\n      ctx.strokeStyle = series.color;\n      plotPoints(\n        series.datapoints,\n        radius,\n        getFillStyle(series.points, series.color),\n        0,\n        false,\n        series.xaxis,\n        series.yaxis,\n        symbol\n      );\n      ctx.restore();\n    }\n\n    function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n      var left, right, bottom, top, drawLeft, drawRight, drawTop, drawBottom, tmp;\n\n      // in horizontal mode, we start the bar from the left\n      // instead of from the bottom so it appears to be\n      // horizontal rather than vertical\n      if (horizontal) {\n        drawBottom = drawRight = drawTop = true;\n        drawLeft = false;\n        left = b;\n        right = x;\n        top = y + barLeft;\n        bottom = y + barRight;\n\n        // account for negative bars\n        if (right < left) {\n          tmp = right;\n          right = left;\n          left = tmp;\n          drawLeft = true;\n          drawRight = false;\n        }\n      } else {\n        drawLeft = drawRight = drawTop = true;\n        drawBottom = false;\n        left = x + barLeft;\n        right = x + barRight;\n        bottom = b;\n        top = y;\n\n        // account for negative bars\n        if (top < bottom) {\n          tmp = top;\n          top = bottom;\n          bottom = tmp;\n          drawBottom = true;\n          drawTop = false;\n        }\n      }\n\n      // clip\n      if (right < axisx.min || left > axisx.max || top < axisy.min || bottom > axisy.max) return;\n\n      if (left < axisx.min) {\n        left = axisx.min;\n        drawLeft = false;\n      }\n\n      if (right > axisx.max) {\n        right = axisx.max;\n        drawRight = false;\n      }\n\n      if (bottom < axisy.min) {\n        bottom = axisy.min;\n        drawBottom = false;\n      }\n\n      if (top > axisy.max) {\n        top = axisy.max;\n        drawTop = false;\n      }\n\n      left = axisx.p2c(left);\n      bottom = axisy.p2c(bottom);\n      right = axisx.p2c(right);\n      top = axisy.p2c(top);\n\n      // fill the bar\n      if (fillStyleCallback) {\n        c.fillStyle = fillStyleCallback(bottom, top);\n        c.fillRect(left, top, right - left, bottom - top);\n      }\n\n      // draw outline\n      if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n        c.beginPath();\n\n        // FIXME: inline moveTo is buggy with excanvas\n        c.moveTo(left, bottom);\n        if (drawLeft) c.lineTo(left, top);\n        else c.moveTo(left, top);\n        if (drawTop) c.lineTo(right, top);\n        else c.moveTo(right, top);\n        if (drawRight) c.lineTo(right, bottom);\n        else c.moveTo(right, bottom);\n        if (drawBottom) c.lineTo(left, bottom);\n        else c.moveTo(left, bottom);\n        c.stroke();\n      }\n    }\n\n    function drawSeriesBars(series) {\n      function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n        var points = datapoints.points,\n          ps = datapoints.pointsize;\n\n        for (let i = 0; i < points.length; i += ps) {\n          if (points[i] == null) continue;\n          drawBar(\n            points[i],\n            points[i + 1],\n            points[i + 2],\n            barLeft,\n            barRight,\n            fillStyleCallback,\n            axisx,\n            axisy,\n            ctx,\n            series.bars.horizontal,\n            series.bars.lineWidth\n          );\n        }\n      }\n\n      ctx.save();\n      ctx.translate(plotOffset.left, plotOffset.top);\n\n      // FIXME: figure out a way to add shadows (for instance along the right edge)\n      ctx.lineWidth = series.bars.lineWidth;\n      ctx.strokeStyle = series.color;\n\n      let barLeft;\n\n      switch (series.bars.align) {\n        case 'left':\n          barLeft = 0;\n          break;\n        case 'right':\n          barLeft = -series.bars.barWidth;\n          break;\n        default:\n          barLeft = -series.bars.barWidth / 2;\n      }\n\n      var fillStyleCallback = series.bars.fill\n        ? function(bottom, top) {\n            return getFillStyle(series.bars, series.color, bottom, top);\n          }\n        : null;\n      plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n      ctx.restore();\n    }\n\n    function getFillStyle(filloptions, seriesColor, bottom, top) {\n      let fill = filloptions.fill;\n      if (!fill) return null;\n\n      if (filloptions.fillColor) return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n\n      let c = $.color.parse(seriesColor);\n      c.a = typeof fill == 'number' ? fill : 0.4;\n      c.normalize();\n      return c.toString();\n    }\n\n    function insertLegend() {\n      if (options.legend.container != null) {\n        $(options.legend.container).html('');\n      } else {\n        placeholder.find('.legend').remove();\n      }\n\n      if (!options.legend.show) {\n        return;\n      }\n\n      var fragments = [],\n        entries = [],\n        rowStarted = false,\n        lf = options.legend.labelFormatter,\n        s,\n        label;\n\n      // Build a list of legend entries, with each having a label and a color\n\n      for (var i = 0; i < series.length; ++i) {\n        s = series[i];\n        if (s.label) {\n          label = lf ? lf(s.label, s) : s.label;\n          if (label) {\n            entries.push({\n              label: label,\n              color: s.color,\n            });\n          }\n        }\n      }\n\n      // Sort the legend using either the default or a custom comparator\n\n      if (options.legend.sorted) {\n        if ($.isFunction(options.legend.sorted)) {\n          entries.sort(options.legend.sorted);\n        } else if (options.legend.sorted == 'reverse') {\n          entries.reverse();\n        } else {\n          var ascending = options.legend.sorted != 'descending';\n          entries.sort(function(a, b) {\n            // eslint-disable-next-line\n            return a.label == b.label ? 0 : a.label < b.label != ascending ? 1 : -1; // Logical XOR\n          });\n        }\n      }\n\n      // Generate markup for the list of entries, in their final order\n\n      for (var i = 0; i < entries.length; ++i) {\n        let entry = entries[i];\n\n        if (i % options.legend.noColumns == 0) {\n          if (rowStarted) fragments.push('</tr>');\n          fragments.push('<tr>');\n          rowStarted = true;\n        }\n\n        fragments.push(\n          '<td class=\"legendColorBox\"><div style=\"border:1px solid ' +\n            options.legend.labelBoxBorderColor +\n            ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' +\n            entry.color +\n            ';overflow:hidden\"></div></div></td>' +\n            '<td class=\"legendLabel\">' +\n            entry.label +\n            '</td>'\n        );\n      }\n\n      if (rowStarted) fragments.push('</tr>');\n\n      if (fragments.length == 0) return;\n\n      var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join('') + '</table>';\n      if (options.legend.container != null) $(options.legend.container).html(table);\n      else {\n        var pos = '',\n          p = options.legend.position,\n          m = options.legend.margin;\n        if (m[0] == null) m = [m, m];\n        if (p.charAt(0) == 'n') pos += 'top:' + (m[1] + plotOffset.top) + 'px;';\n        else if (p.charAt(0) == 's') pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n        if (p.charAt(1) == 'e') pos += 'right:' + (m[0] + plotOffset.right) + 'px;';\n        else if (p.charAt(1) == 'w') pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n        var legend = $(\n          '<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos + ';') + '</div>'\n        ).appendTo(placeholder);\n        if (options.legend.backgroundOpacity != 0.0) {\n          // put in the transparent background\n          // separately to avoid blended labels and\n          // label boxes\n          let c = options.legend.backgroundColor;\n          if (c == null) {\n            c = options.grid.backgroundColor;\n            if (c && typeof c == 'string') c = $.color.parse(c);\n            else c = $.color.extract(legend, 'background-color');\n            c.a = 1;\n            c = c.toString();\n          }\n          let div = legend.children();\n          $(\n            '<div style=\"position:absolute;width:' +\n              div.width() +\n              'px;height:' +\n              div.height() +\n              'px;' +\n              pos +\n              'background-color:' +\n              c +\n              ';\"> </div>'\n          )\n            .prependTo(legend)\n            .css('opacity', options.legend.backgroundOpacity);\n        }\n      }\n    }\n\n    // interactive features\n\n    var highlights = [],\n      redrawTimeout = null;\n\n    // returns the data item the mouse is over, or null if none is found\n    function findNearbyItem(mouseX, mouseY, seriesFilter) {\n      let maxDistance = options.grid.mouseActiveRadius,\n        smallestDistance = maxDistance * maxDistance + 1,\n        item = null,\n        i,\n        j,\n        ps;\n\n      for (i = series.length - 1; i >= 0; --i) {\n        if (!seriesFilter(series[i])) continue;\n\n        let s = series[i],\n          axisx = s.xaxis,\n          axisy = s.yaxis,\n          points = s.datapoints.points,\n          mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster\n          my = axisy.c2p(mouseY),\n          maxx = maxDistance / axisx.scale,\n          maxy = maxDistance / axisy.scale;\n\n        ps = s.datapoints.pointsize;\n        // with inverse transforms, we can't use the maxx/maxy\n        // optimization, sadly\n        if (axisx.options.inverseTransform) maxx = Number.MAX_VALUE;\n        if (axisy.options.inverseTransform) maxy = Number.MAX_VALUE;\n\n        if (s.lines.show || s.points.show) {\n          for (j = 0; j < points.length; j += ps) {\n            var x = points[j],\n              y = points[j + 1];\n            if (x == null) continue;\n\n            // For points and lines, the cursor must be within a\n            // certain distance to the data point\n            if (x - mx > maxx || x - mx < -maxx || y - my > maxy || y - my < -maxy) continue;\n\n            // We have to calculate distances in pixels, not in\n            // data units, because the scales of the axes may be different\n            let dx = Math.abs(axisx.p2c(x) - mouseX),\n              dy = Math.abs(axisy.p2c(y) - mouseY),\n              dist = dx * dx + dy * dy; // we save the sqrt\n\n            // use <= to ensure last point takes precedence\n            // (last generally means on top of)\n            if (dist < smallestDistance) {\n              smallestDistance = dist;\n              item = [i, j / ps];\n            }\n          }\n        }\n\n        if (s.bars.show && !item) {\n          // no other point can be nearby\n\n          var barLeft, barRight;\n\n          switch (s.bars.align) {\n            case 'left':\n              barLeft = 0;\n              break;\n            case 'right':\n              barLeft = -s.bars.barWidth;\n              break;\n            default:\n              barLeft = -s.bars.barWidth / 2;\n          }\n\n          barRight = barLeft + s.bars.barWidth;\n\n          for (j = 0; j < points.length; j += ps) {\n            var x = points[j],\n              y = points[j + 1],\n              b = points[j + 2];\n            if (x == null) continue;\n\n            // for a bar graph, the cursor must be inside the bar\n            if (\n              series[i].bars.horizontal\n                ? mx <= Math.max(b, x) && mx >= Math.min(b, x) && my >= y + barLeft && my <= y + barRight\n                : mx >= x + barLeft && mx <= x + barRight && my >= Math.min(b, y) && my <= Math.max(b, y)\n            )\n              item = [i, j / ps];\n          }\n        }\n      }\n\n      if (item) {\n        i = item[0];\n        j = item[1];\n        ps = series[i].datapoints.pointsize;\n\n        return {\n          datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n          dataIndex: j,\n          series: series[i],\n          seriesIndex: i,\n        };\n      }\n\n      return null;\n    }\n\n    function onMouseMove(e) {\n      if (options.grid.hoverable)\n        triggerClickHoverEvent('plothover', e, function(s) {\n          return s['hoverable'] != false;\n        });\n    }\n\n    function onMouseLeave(e) {\n      if (options.grid.hoverable)\n        triggerClickHoverEvent('plothover', e, function() {\n          return false;\n        });\n    }\n\n    function onClick(e) {\n      if (plot.isSelecting) {\n        return;\n      }\n\n      triggerClickHoverEvent('plotclick', e, function(s) {\n        return s['clickable'] != false;\n      });\n    }\n\n    // trigger click or hover event (they send the same parameters\n    // so we share their code)\n    function triggerClickHoverEvent(eventname, event, seriesFilter) {\n      let offset = eventHolder.offset(),\n        canvasX = event.pageX - offset.left - plotOffset.left,\n        canvasY = event.pageY - offset.top - plotOffset.top,\n        pos = canvasToAxisCoords({ left: canvasX, top: canvasY });\n\n      pos.pageX = event.pageX;\n      pos.pageY = event.pageY;\n\n      // Add ctrlKey and metaKey to event\n      pos.ctrlKey = event.ctrlKey;\n      pos.metaKey = event.metaKey;\n\n      let item = findNearbyItem(canvasX, canvasY, seriesFilter);\n\n      if (item) {\n        // fill in mouse pos for any listeners out there\n        item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\n        item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);\n      }\n\n      if (options.grid.autoHighlight) {\n        // clear auto-highlights\n        for (let i = 0; i < highlights.length; ++i) {\n          let h = highlights[i];\n          if (\n            h.auto == eventname &&\n            !(item && h.series == item.series && h.point[0] == item.datapoint[0] && h.point[1] == item.datapoint[1])\n          )\n            unhighlight(h.series, h.point);\n        }\n\n        if (item) highlight(item.series, item.datapoint, eventname);\n      }\n\n      placeholder.trigger(eventname, [pos, item]);\n    }\n\n    function triggerRedrawOverlay() {\n      let t = options.interaction.redrawOverlayInterval;\n      if (t == -1) {\n        // skip event queue\n        drawOverlay();\n        return;\n      }\n\n      if (!redrawTimeout) redrawTimeout = setTimeout(drawOverlay, t);\n    }\n\n    function drawOverlay() {\n      redrawTimeout = null;\n\n      // draw highlights\n      octx.save();\n      overlay.clear();\n      octx.translate(plotOffset.left, plotOffset.top);\n\n      let i, hi;\n      for (i = 0; i < highlights.length; ++i) {\n        hi = highlights[i];\n\n        if (hi.series.bars.show) drawBarHighlight(hi.series, hi.point);\n        else drawPointHighlight(hi.series, hi.point);\n      }\n      octx.restore();\n\n      executeHooks(hooks.drawOverlay, [octx]);\n    }\n\n    function highlight(s, point, auto) {\n      if (typeof s == 'number') s = series[s];\n\n      if (typeof point == 'number') {\n        let ps = s.datapoints.pointsize;\n        point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n      }\n\n      let i = indexOfHighlight(s, point);\n      if (i == -1) {\n        highlights.push({ series: s, point: point, auto: auto });\n\n        triggerRedrawOverlay();\n      } else if (!auto) highlights[i].auto = false;\n    }\n\n    function unhighlight(s, point) {\n      if (s == null && point == null) {\n        highlights = [];\n        triggerRedrawOverlay();\n        return;\n      }\n\n      if (typeof s == 'number') s = series[s];\n\n      if (typeof point == 'number') {\n        let ps = s.datapoints.pointsize;\n        point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n      }\n\n      let i = indexOfHighlight(s, point);\n      if (i != -1) {\n        highlights.splice(i, 1);\n\n        triggerRedrawOverlay();\n      }\n    }\n\n    function indexOfHighlight(s, p) {\n      for (let i = 0; i < highlights.length; ++i) {\n        let h = highlights[i];\n        if (h.series == s && h.point[0] == p[0] && h.point[1] == p[1]) return i;\n      }\n      return -1;\n    }\n\n    function drawPointHighlight(series, point) {\n      var x = point[0],\n        y = point[1],\n        axisx = series.xaxis,\n        axisy = series.yaxis,\n        highlightColor =\n          typeof series.highlightColor === 'string'\n            ? series.highlightColor\n            : $.color\n                .parse(series.color)\n                .scale('a', 0.5)\n                .toString();\n\n      if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) return;\n\n      let pointRadius = series.points.radius + series.points.lineWidth / 2;\n      octx.lineWidth = pointRadius;\n      octx.strokeStyle = highlightColor;\n      let radius = 1.5 * pointRadius;\n      x = axisx.p2c(x);\n      y = axisy.p2c(y);\n\n      octx.beginPath();\n      if (series.points.symbol == 'circle') octx.arc(x, y, radius, 0, 2 * Math.PI, false);\n      else series.points.symbol(octx, x, y, radius, false);\n      octx.closePath();\n      octx.stroke();\n    }\n\n    function drawBarHighlight(series, point) {\n      var highlightColor =\n          typeof series.highlightColor === 'string'\n            ? series.highlightColor\n            : $.color\n                .parse(series.color)\n                .scale('a', 0.5)\n                .toString(),\n        fillStyle = highlightColor,\n        barLeft;\n\n      switch (series.bars.align) {\n        case 'left':\n          barLeft = 0;\n          break;\n        case 'right':\n          barLeft = -series.bars.barWidth;\n          break;\n        default:\n          barLeft = -series.bars.barWidth / 2;\n      }\n\n      octx.lineWidth = series.bars.lineWidth;\n      octx.strokeStyle = highlightColor;\n\n      drawBar(\n        point[0],\n        point[1],\n        point[2] || 0,\n        barLeft,\n        barLeft + series.bars.barWidth,\n        function() {\n          return fillStyle;\n        },\n        series.xaxis,\n        series.yaxis,\n        octx,\n        series.bars.horizontal,\n        series.bars.lineWidth\n      );\n    }\n\n    function getColorOrGradient(spec, bottom, top, defaultColor) {\n      if (typeof spec == 'string') return spec;\n      else {\n        // assume this is a gradient spec; IE currently only\n        // supports a simple vertical gradient properly, so that's\n        // what we support too\n        let gradient = ctx.createLinearGradient(0, top, 0, bottom);\n\n        for (let i = 0, l = spec.colors.length; i < l; ++i) {\n          let c = spec.colors[i];\n          if (typeof c != 'string') {\n            let co = $.color.parse(defaultColor);\n            if (c.brightness != null) co = co.scale('rgb', c.brightness);\n            if (c.opacity != null) co.a *= c.opacity;\n            c = co.toString();\n          }\n          gradient.addColorStop(i / (l - 1), c);\n        }\n\n        return gradient;\n      }\n    }\n  }\n\n  // Add the plot function to the top level of the jQuery object\n\n  $.plot = function(placeholder, data, options) {\n    //var t0 = new Date();\n    let plot = new Plot($(placeholder), data, options, $.plot.plugins);\n    //(window.console ? console.log : alert)(\"time used (msecs): \" + ((new Date()).getTime() - t0.getTime()));\n    return plot;\n  };\n\n  $.plot.version = '0.8.3';\n\n  $.plot.plugins = [];\n\n  // Also add the plot function as a chainable property\n\n  $.fn.plot = function(data, options) {\n    return this.each(function() {\n      $.plot(this, data, options);\n    });\n  };\n\n  // round to nearby lower multiple of base\n  function floorInBase(n, base) {\n    return base * Math.floor(n / base);\n  }\n})(window.jQuery);\n"]},"metadata":{},"sourceType":"module"}