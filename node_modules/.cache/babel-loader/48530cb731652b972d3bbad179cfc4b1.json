{"ast":null,"code":"import _objectSpread from \"/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport $ from 'jquery';\nimport { escapeHTML } from '../../utils';\nimport moment from 'moment-timezone';\nexport var formatValue = function formatValue(y) {\n  if (y === null) {\n    return 'null';\n  }\n\n  var absY = Math.abs(y);\n\n  if (absY >= 1e24) {\n    return (y / 1e24).toFixed(2) + 'Y';\n  } else if (absY >= 1e21) {\n    return (y / 1e21).toFixed(2) + 'Z';\n  } else if (absY >= 1e18) {\n    return (y / 1e18).toFixed(2) + 'E';\n  } else if (absY >= 1e15) {\n    return (y / 1e15).toFixed(2) + 'P';\n  } else if (absY >= 1e12) {\n    return (y / 1e12).toFixed(2) + 'T';\n  } else if (absY >= 1e9) {\n    return (y / 1e9).toFixed(2) + 'G';\n  } else if (absY >= 1e6) {\n    return (y / 1e6).toFixed(2) + 'M';\n  } else if (absY >= 1e3) {\n    return (y / 1e3).toFixed(2) + 'k';\n  } else if (absY >= 1) {\n    return y.toFixed(2);\n  } else if (absY === 0) {\n    return y.toFixed(2);\n  } else if (absY < 1e-23) {\n    return (y / 1e-24).toFixed(2) + 'y';\n  } else if (absY < 1e-20) {\n    return (y / 1e-21).toFixed(2) + 'z';\n  } else if (absY < 1e-17) {\n    return (y / 1e-18).toFixed(2) + 'a';\n  } else if (absY < 1e-14) {\n    return (y / 1e-15).toFixed(2) + 'f';\n  } else if (absY < 1e-11) {\n    return (y / 1e-12).toFixed(2) + 'p';\n  } else if (absY < 1e-8) {\n    return (y / 1e-9).toFixed(2) + 'n';\n  } else if (absY < 1e-5) {\n    return (y / 1e-6).toFixed(2) + 'Âµ';\n  } else if (absY < 1e-2) {\n    return (y / 1e-3).toFixed(2) + 'm';\n  } else if (absY <= 1) {\n    return y.toFixed(2);\n  }\n\n  throw Error(\"couldn't format a value, this is a bug\");\n};\nexport var getHoverColor = function getHoverColor(color, opacity, stacked) {\n  var _$$color$parse = $.color.parse(color),\n      r = _$$color$parse.r,\n      g = _$$color$parse.g,\n      b = _$$color$parse.b;\n\n  if (!stacked) {\n    return \"rgba(\".concat(r, \", \").concat(g, \", \").concat(b, \", \").concat(opacity, \")\");\n  }\n  /*\n    Unfortunately flot doesn't take into consideration\n    the alpha value when adjusting the color on the stacked series.\n    TODO: find better way to set the opacity.\n  */\n\n\n  var base = (1 - opacity) * 255;\n  return \"rgb(\".concat(Math.round(base + opacity * r), \",\").concat(Math.round(base + opacity * g), \",\").concat(Math.round(base + opacity * b), \")\");\n};\nexport var toHoverColor = function toHoverColor(index, stacked) {\n  return function (series, i) {\n    return _objectSpread(_objectSpread({}, series), {}, {\n      color: getHoverColor(series.color, i !== index ? 0.3 : 1, stacked)\n    });\n  };\n};\nexport var getOptions = function getOptions(stacked, useLocalTime) {\n  return {\n    grid: {\n      hoverable: true,\n      clickable: true,\n      autoHighlight: true,\n      mouseActiveRadius: 100\n    },\n    legend: {\n      show: false\n    },\n    xaxis: {\n      mode: 'time',\n      showTicks: true,\n      showMinorTicks: true,\n      timeBase: 'milliseconds',\n      timezone: useLocalTime ? 'browser' : undefined\n    },\n    yaxis: {\n      tickFormatter: formatValue\n    },\n    crosshair: {\n      mode: 'xy',\n      color: '#bbb'\n    },\n    tooltip: {\n      show: true,\n      cssClass: 'graph-tooltip',\n      content: function content(_, xval, yval, _ref) {\n        var series = _ref.series;\n        var labels = series.labels,\n            color = series.color;\n        var dateTime = moment(xval);\n\n        if (!useLocalTime) {\n          dateTime = dateTime.utc();\n        }\n\n        return \"\\n            <div class=\\\"date\\\">\".concat(dateTime.format('YYYY-MM-DD HH:mm:ss Z'), \"</div>\\n            <div>\\n              <span class=\\\"detail-swatch\\\" style=\\\"background-color: \").concat(color, \"\\\"></span>\\n              <span>\").concat(labels.__name__ || 'value', \": <strong>\").concat(yval, \"</strong></span>\\n            <div>\\n            <div class=\\\"labels mt-1\\\">\\n              \").concat(Object.keys(labels).map(function (k) {\n          return k !== '__name__' ? \"<div class=\\\"mb-1\\\"><strong>\".concat(k, \"</strong>: \").concat(escapeHTML(labels[k]), \"</div>\") : '';\n        }).join(''), \"\\n            </div>\\n          \");\n      },\n      defaultTheme: false,\n      lines: true\n    },\n    series: {\n      stack: stacked,\n      lines: {\n        lineWidth: stacked ? 1 : 2,\n        steps: false,\n        fill: stacked\n      },\n      shadowSize: 0\n    }\n  };\n}; // This was adapted from Flot's color generation code.\n\nexport var getColors = function getColors(data) {\n  var colorPool = ['#edc240', '#afd8f8', '#cb4b4b', '#4da74d', '#9440ed'];\n  var colorPoolSize = colorPool.length;\n  var variation = 0;\n  return data.result.map(function (_, i) {\n    // Each time we exhaust the colors in the pool we adjust\n    // a scaling factor used to produce more variations on\n    // those colors. The factor alternates negative/positive\n    // to produce lighter/darker colors.\n    // Reset the variation after every few cycles, or else\n    // it will end up producing only white or black colors.\n    if (i % colorPoolSize === 0 && i) {\n      if (variation >= 0) {\n        variation = variation < 0.5 ? -variation - 0.2 : 0;\n      } else {\n        variation = -variation;\n      }\n    }\n\n    return $.color.parse(colorPool[i % colorPoolSize] || '#666').scale('rgb', 1 + variation);\n  });\n};\nexport var normalizeData = function normalizeData(_ref2) {\n  var queryParams = _ref2.queryParams,\n      data = _ref2.data;\n  var colors = getColors(data);\n  var _ref3 = queryParams,\n      startTime = _ref3.startTime,\n      endTime = _ref3.endTime,\n      resolution = _ref3.resolution;\n  return data.result.map(function (_ref4, index) {\n    var values = _ref4.values,\n        metric = _ref4.metric;\n    // Insert nulls for all missing steps.\n    var data = [];\n    var pos = 0;\n\n    for (var t = startTime; t <= endTime; t += resolution) {\n      // Allow for floating point inaccuracy.\n      var currentValue = values[pos];\n\n      if (values.length > pos && currentValue[0] < t + resolution / 100) {\n        data.push([currentValue[0] * 1000, parseValue(currentValue[1])]);\n        pos++;\n      } else {\n        data.push([t * 1000, null]);\n      }\n    }\n\n    return {\n      labels: metric !== null ? metric : {},\n      color: colors[index].toString(),\n      data,\n      index\n    };\n  });\n};\nexport var parseValue = function parseValue(value) {\n  var val = parseFloat(value); // \"+Inf\", \"-Inf\", \"+Inf\" will be parsed into NaN by parseFloat(). They\n  // can't be graphed, so show them as gaps (null).\n\n  return isNaN(val) ? null : val;\n};","map":{"version":3,"sources":["/app/src/pages/graph/GraphHelpers.ts"],"names":["$","escapeHTML","moment","formatValue","y","absY","Math","abs","toFixed","Error","getHoverColor","color","opacity","stacked","parse","r","g","b","base","round","toHoverColor","index","series","i","getOptions","useLocalTime","grid","hoverable","clickable","autoHighlight","mouseActiveRadius","legend","show","xaxis","mode","showTicks","showMinorTicks","timeBase","timezone","undefined","yaxis","tickFormatter","crosshair","tooltip","cssClass","content","_","xval","yval","labels","dateTime","utc","format","__name__","Object","keys","map","k","join","defaultTheme","lines","stack","lineWidth","steps","fill","shadowSize","getColors","data","colorPool","colorPoolSize","length","variation","result","scale","normalizeData","queryParams","colors","startTime","endTime","resolution","values","metric","pos","t","currentValue","push","parseValue","toString","value","val","parseFloat","isNaN"],"mappings":"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","sourcesContent":["import $ from 'jquery';\n\nimport { escapeHTML } from '../../utils';\nimport { Metric } from '../../types/types';\nimport { GraphProps, GraphSeries } from './Graph';\nimport moment from 'moment-timezone';\n\nexport const formatValue = (y: number | null): string => {\n  if (y === null) {\n    return 'null';\n  }\n  const absY = Math.abs(y);\n\n  if (absY >= 1e24) {\n    return (y / 1e24).toFixed(2) + 'Y';\n  } else if (absY >= 1e21) {\n    return (y / 1e21).toFixed(2) + 'Z';\n  } else if (absY >= 1e18) {\n    return (y / 1e18).toFixed(2) + 'E';\n  } else if (absY >= 1e15) {\n    return (y / 1e15).toFixed(2) + 'P';\n  } else if (absY >= 1e12) {\n    return (y / 1e12).toFixed(2) + 'T';\n  } else if (absY >= 1e9) {\n    return (y / 1e9).toFixed(2) + 'G';\n  } else if (absY >= 1e6) {\n    return (y / 1e6).toFixed(2) + 'M';\n  } else if (absY >= 1e3) {\n    return (y / 1e3).toFixed(2) + 'k';\n  } else if (absY >= 1) {\n    return y.toFixed(2);\n  } else if (absY === 0) {\n    return y.toFixed(2);\n  } else if (absY < 1e-23) {\n    return (y / 1e-24).toFixed(2) + 'y';\n  } else if (absY < 1e-20) {\n    return (y / 1e-21).toFixed(2) + 'z';\n  } else if (absY < 1e-17) {\n    return (y / 1e-18).toFixed(2) + 'a';\n  } else if (absY < 1e-14) {\n    return (y / 1e-15).toFixed(2) + 'f';\n  } else if (absY < 1e-11) {\n    return (y / 1e-12).toFixed(2) + 'p';\n  } else if (absY < 1e-8) {\n    return (y / 1e-9).toFixed(2) + 'n';\n  } else if (absY < 1e-5) {\n    return (y / 1e-6).toFixed(2) + 'Âµ';\n  } else if (absY < 1e-2) {\n    return (y / 1e-3).toFixed(2) + 'm';\n  } else if (absY <= 1) {\n    return y.toFixed(2);\n  }\n  throw Error(\"couldn't format a value, this is a bug\");\n};\n\nexport const getHoverColor = (color: string, opacity: number, stacked: boolean) => {\n  const { r, g, b } = $.color.parse(color);\n  if (!stacked) {\n    return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n  }\n  /*\n    Unfortunately flot doesn't take into consideration\n    the alpha value when adjusting the color on the stacked series.\n    TODO: find better way to set the opacity.\n  */\n  const base = (1 - opacity) * 255;\n  return `rgb(${Math.round(base + opacity * r)},${Math.round(base + opacity * g)},${Math.round(base + opacity * b)})`;\n};\n\nexport const toHoverColor = (index: number, stacked: boolean) => (series: GraphSeries, i: number) => ({\n  ...series,\n  color: getHoverColor(series.color, i !== index ? 0.3 : 1, stacked),\n});\n\nexport const getOptions = (stacked: boolean, useLocalTime: boolean): jquery.flot.plotOptions => {\n  return {\n    grid: {\n      hoverable: true,\n      clickable: true,\n      autoHighlight: true,\n      mouseActiveRadius: 100,\n    },\n    legend: {\n      show: false,\n    },\n    xaxis: {\n      mode: 'time',\n      showTicks: true,\n      showMinorTicks: true,\n      timeBase: 'milliseconds',\n      timezone: useLocalTime ? 'browser' : undefined,\n    },\n    yaxis: {\n      tickFormatter: formatValue,\n    },\n    crosshair: {\n      mode: 'xy',\n      color: '#bbb',\n    },\n    tooltip: {\n      show: true,\n      cssClass: 'graph-tooltip',\n      content: (_, xval, yval, { series }): string => {\n        const { labels, color } = series;\n        let dateTime = moment(xval);\n        if (!useLocalTime) {\n          dateTime = dateTime.utc();\n        }\n        return `\n            <div class=\"date\">${dateTime.format('YYYY-MM-DD HH:mm:ss Z')}</div>\n            <div>\n              <span class=\"detail-swatch\" style=\"background-color: ${color}\"></span>\n              <span>${labels.__name__ || 'value'}: <strong>${yval}</strong></span>\n            <div>\n            <div class=\"labels mt-1\">\n              ${Object.keys(labels)\n                .map(k =>\n                  k !== '__name__' ? `<div class=\"mb-1\"><strong>${k}</strong>: ${escapeHTML(labels[k])}</div>` : ''\n                )\n                .join('')}\n            </div>\n          `;\n      },\n      defaultTheme: false,\n      lines: true,\n    },\n    series: {\n      stack: stacked,\n      lines: {\n        lineWidth: stacked ? 1 : 2,\n        steps: false,\n        fill: stacked,\n      },\n      shadowSize: 0,\n    },\n  };\n};\n\n// This was adapted from Flot's color generation code.\nexport const getColors = (data: { resultType: string; result: Array<{ metric: Metric; values: [number, string][] }> }) => {\n  const colorPool = ['#edc240', '#afd8f8', '#cb4b4b', '#4da74d', '#9440ed'];\n  const colorPoolSize = colorPool.length;\n  let variation = 0;\n  return data.result.map((_, i) => {\n    // Each time we exhaust the colors in the pool we adjust\n    // a scaling factor used to produce more variations on\n    // those colors. The factor alternates negative/positive\n    // to produce lighter/darker colors.\n\n    // Reset the variation after every few cycles, or else\n    // it will end up producing only white or black colors.\n\n    if (i % colorPoolSize === 0 && i) {\n      if (variation >= 0) {\n        variation = variation < 0.5 ? -variation - 0.2 : 0;\n      } else {\n        variation = -variation;\n      }\n    }\n    return $.color.parse(colorPool[i % colorPoolSize] || '#666').scale('rgb', 1 + variation);\n  });\n};\n\nexport const normalizeData = ({ queryParams, data }: GraphProps): GraphSeries[] => {\n  const colors = getColors(data);\n  const { startTime, endTime, resolution } = queryParams!;\n  return data.result.map(({ values, metric }, index) => {\n    // Insert nulls for all missing steps.\n    const data = [];\n    let pos = 0;\n\n    for (let t = startTime; t <= endTime; t += resolution) {\n      // Allow for floating point inaccuracy.\n      const currentValue = values[pos];\n      if (values.length > pos && currentValue[0] < t + resolution / 100) {\n        data.push([currentValue[0] * 1000, parseValue(currentValue[1])]);\n        pos++;\n      } else {\n        data.push([t * 1000, null]);\n      }\n    }\n\n    return {\n      labels: metric !== null ? metric : {},\n      color: colors[index].toString(),\n      data,\n      index,\n    };\n  });\n};\n\nexport const parseValue = (value: string) => {\n  const val = parseFloat(value);\n  // \"+Inf\", \"-Inf\", \"+Inf\" will be parsed into NaN by parseFloat(). They\n  // can't be graphed, so show them as gaps (null).\n  return isNaN(val) ? null : val;\n};\n"]},"metadata":{},"sourceType":"module"}