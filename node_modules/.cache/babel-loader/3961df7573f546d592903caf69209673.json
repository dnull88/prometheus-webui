{"ast":null,"code":"import _slicedToArray from \"/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport moment from 'moment-timezone';\nimport { PanelType, PanelDefaultOptions } from '../pages/graph/Panel';\nexport var generateID = function generateID() {\n  return \"_\".concat(Math.random().toString(36).substr(2, 9));\n};\nexport var byEmptyString = function byEmptyString(p) {\n  return p.length > 0;\n};\nexport var isPresent = function isPresent(obj) {\n  return obj !== null && obj !== undefined;\n};\nexport var escapeHTML = function escapeHTML(str) {\n  var entityMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;'\n  };\n  return String(str).replace(/[&<>\"'/]/g, function (s) {\n    return entityMap[s];\n  });\n};\nexport var metricToSeriesName = function metricToSeriesName(labels) {\n  if (labels === null) {\n    return 'scalar';\n  }\n\n  var tsName = (labels.__name__ || '') + '{';\n  var labelStrings = [];\n\n  for (var label in labels) {\n    if (label !== '__name__') {\n      labelStrings.push(label + '=\"' + labels[label] + '\"');\n    }\n  }\n\n  tsName += labelStrings.join(', ') + '}';\n  return tsName;\n};\nexport var parseDuration = function parseDuration(durationStr) {\n  if (durationStr === '') {\n    return null;\n  }\n\n  if (durationStr === '0') {\n    // Allow 0 without a unit.\n    return 0;\n  }\n\n  var durationRE = new RegExp('^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$');\n  var matches = durationStr.match(durationRE);\n\n  if (!matches) {\n    return null;\n  }\n\n  var dur = 0; // Parse the match at pos `pos` in the regex and use `mult` to turn that\n  // into ms, then add that value to the total parsed duration.\n\n  var m = function m(pos, mult) {\n    if (matches[pos] === undefined) {\n      return;\n    }\n\n    var n = parseInt(matches[pos]);\n    dur += n * mult;\n  };\n\n  m(2, 1000 * 60 * 60 * 24 * 365); // y\n\n  m(4, 1000 * 60 * 60 * 24 * 7); // w\n\n  m(6, 1000 * 60 * 60 * 24); // d\n\n  m(8, 1000 * 60 * 60); // h\n\n  m(10, 1000 * 60); // m\n\n  m(12, 1000); // s\n\n  m(14, 1); // ms\n\n  return dur;\n};\nexport var formatDuration = function formatDuration(d) {\n  var ms = d;\n  var r = '';\n\n  if (ms === 0) {\n    return '0s';\n  }\n\n  var f = function f(unit, mult, exact) {\n    if (exact && ms % mult !== 0) {\n      return;\n    }\n\n    var v = Math.floor(ms / mult);\n\n    if (v > 0) {\n      r += \"\".concat(v).concat(unit);\n      ms -= v * mult;\n    }\n  }; // Only format years and weeks if the remainder is zero, as it is often\n  // easier to read 90d than 12w6d.\n\n\n  f('y', 1000 * 60 * 60 * 24 * 365, true);\n  f('w', 1000 * 60 * 60 * 24 * 7, true);\n  f('d', 1000 * 60 * 60 * 24, false);\n  f('h', 1000 * 60 * 60, false);\n  f('m', 1000 * 60, false);\n  f('s', 1000, false);\n  f('ms', 1, false);\n  return r;\n};\nexport function parseTime(timeText) {\n  return moment.utc(timeText).valueOf();\n}\nexport function formatTime(time) {\n  return moment.utc(time).format('YYYY-MM-DD HH:mm:ss');\n}\nexport var now = function now() {\n  return moment().valueOf();\n};\nexport var humanizeDuration = function humanizeDuration(milliseconds) {\n  var sign = milliseconds < 0 ? '-' : '';\n  var unsignedMillis = milliseconds < 0 ? -1 * milliseconds : milliseconds;\n  var duration = moment.duration(unsignedMillis, 'ms');\n  var ms = Math.floor(duration.milliseconds());\n  var s = Math.floor(duration.seconds());\n  var m = Math.floor(duration.minutes());\n  var h = Math.floor(duration.hours());\n  var d = Math.floor(duration.asDays());\n\n  if (d !== 0) {\n    return \"\".concat(sign).concat(d, \"d \").concat(h, \"h \").concat(m, \"m \").concat(s, \"s\");\n  }\n\n  if (h !== 0) {\n    return \"\".concat(sign).concat(h, \"h \").concat(m, \"m \").concat(s, \"s\");\n  }\n\n  if (m !== 0) {\n    return \"\".concat(sign).concat(m, \"m \").concat(s, \"s\");\n  }\n\n  if (s !== 0) {\n    return \"\".concat(sign).concat(s, \".\").concat(ms, \"s\");\n  }\n\n  if (unsignedMillis > 0) {\n    return \"\".concat(sign).concat(unsignedMillis.toFixed(3), \"ms\");\n  }\n\n  return '0s';\n};\nexport var formatRelative = function formatRelative(startStr, end) {\n  var start = parseTime(startStr);\n\n  if (start < 0) {\n    return 'Never';\n  }\n\n  return humanizeDuration(end - start);\n};\nvar paramFormat = /^g\\d+\\..+=.+$/;\nexport var decodePanelOptionsFromQueryString = function decodePanelOptionsFromQueryString(query) {\n  if (query === '') {\n    return [];\n  }\n\n  var urlParams = query.substring(1).split('&');\n  return urlParams.reduce(function (panels, urlParam, i) {\n    var panelsCount = panels.length;\n    var prefix = \"g\".concat(panelsCount, \".\");\n\n    if (urlParam.startsWith(\"\".concat(prefix, \"expr=\"))) {\n      var prefixLen = prefix.length;\n      return [].concat(_toConsumableArray(panels), [{\n        id: generateID(),\n        key: \"\".concat(panelsCount),\n        options: urlParams.slice(i).reduce(function (opts, param) {\n          return param.startsWith(prefix) && paramFormat.test(param) ? _objectSpread(_objectSpread({}, opts), parseOption(param.substring(prefixLen))) : opts;\n        }, PanelDefaultOptions)\n      }]);\n    }\n\n    return panels;\n  }, []);\n};\nexport var parseOption = function parseOption(param) {\n  var _param$split = param.split('='),\n      _param$split2 = _slicedToArray(_param$split, 2),\n      opt = _param$split2[0],\n      val = _param$split2[1];\n\n  var decodedValue = decodeURIComponent(val.replace(/\\+/g, ' '));\n\n  switch (opt) {\n    case 'expr':\n      return {\n        expr: decodedValue\n      };\n\n    case 'tab':\n      return {\n        type: decodedValue === '0' ? PanelType.Graph : PanelType.Table\n      };\n\n    case 'stacked':\n      return {\n        stacked: decodedValue === '1'\n      };\n\n    case 'range_input':\n      var range = parseDuration(decodedValue);\n      return isPresent(range) ? {\n        range\n      } : {};\n\n    case 'end_input':\n    case 'moment_input':\n      return {\n        endTime: parseTime(decodedValue)\n      };\n\n    case 'step_input':\n      var resolution = parseInt(decodedValue);\n      return resolution > 0 ? {\n        resolution\n      } : {};\n  }\n\n  return {};\n};\nexport var formatParam = function formatParam(key) {\n  return function (paramName, value) {\n    return \"g\".concat(key, \".\").concat(paramName, \"=\").concat(encodeURIComponent(value));\n  };\n};\nexport var toQueryString = function toQueryString(_ref) {\n  var key = _ref.key,\n      options = _ref.options;\n  var formatWithKey = formatParam(key);\n  var expr = options.expr,\n      type = options.type,\n      stacked = options.stacked,\n      range = options.range,\n      endTime = options.endTime,\n      resolution = options.resolution;\n  var time = isPresent(endTime) ? formatTime(endTime) : false;\n  var urlParams = [formatWithKey('expr', expr), formatWithKey('tab', type === PanelType.Graph ? 0 : 1), formatWithKey('stacked', stacked ? 1 : 0), formatWithKey('range_input', formatDuration(range)), time ? \"\".concat(formatWithKey('end_input', time), \"&\").concat(formatWithKey('moment_input', time)) : '', isPresent(resolution) ? formatWithKey('step_input', resolution) : ''];\n  return urlParams.filter(byEmptyString).join('&');\n};\nexport var encodePanelOptionsToQueryString = function encodePanelOptionsToQueryString(panels) {\n  return \"?\".concat(panels.map(toQueryString).join('&'));\n};\nexport var createExpressionLink = function createExpressionLink(expr) {\n  return \"../graph?g0.expr=\".concat(encodeURIComponent(expr), \"&g0.tab=1&g0.stacked=0&g0.range_input=1h\");\n};\nexport var mapObjEntries = function mapObjEntries(o, cb) {\n  return Object.entries(o).map(cb);\n};\nexport var callAll = function callAll() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    // eslint-disable-next-line prefer-spread\n    fns.filter(Boolean).forEach(function (fn) {\n      return fn.apply(null, args);\n    });\n  };\n};\nexport var parsePrometheusFloat = function parsePrometheusFloat(value) {\n  if (isNaN(Number(value))) {\n    return value;\n  } else {\n    return Number(value);\n  }\n};","map":{"version":3,"sources":["/app/src/utils/index.ts"],"names":["moment","PanelType","PanelDefaultOptions","generateID","Math","random","toString","substr","byEmptyString","p","length","isPresent","obj","undefined","escapeHTML","str","entityMap","String","replace","s","metricToSeriesName","labels","tsName","__name__","labelStrings","label","push","join","parseDuration","durationStr","durationRE","RegExp","matches","match","dur","m","pos","mult","n","parseInt","formatDuration","d","ms","r","f","unit","exact","v","floor","parseTime","timeText","utc","valueOf","formatTime","time","format","now","humanizeDuration","milliseconds","sign","unsignedMillis","duration","seconds","minutes","h","hours","asDays","toFixed","formatRelative","startStr","end","start","paramFormat","decodePanelOptionsFromQueryString","query","urlParams","substring","split","reduce","panels","urlParam","i","panelsCount","prefix","startsWith","prefixLen","id","key","options","slice","opts","param","test","parseOption","opt","val","decodedValue","decodeURIComponent","expr","type","Graph","Table","stacked","range","endTime","resolution","formatParam","paramName","value","encodeURIComponent","toQueryString","formatWithKey","filter","encodePanelOptionsToQueryString","map","createExpressionLink","mapObjEntries","o","cb","Object","entries","callAll","fns","args","Boolean","forEach","fn","apply","parsePrometheusFloat","isNaN","Number"],"mappings":";;;AAAA,OAAOA,MAAP,MAAmB,iBAAnB;AAEA,SAAuBC,SAAvB,EAAkCC,mBAAlC,QAA6D,sBAA7D;AAGA,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa,GAAM;AAC9B,oBAAWC,IAAI,CAACC,MAAL,GACRC,QADQ,CACC,EADD,EAERC,MAFQ,CAED,CAFC,EAEE,CAFF,CAAX;AAGD,CAJM;AAMP,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,CAAD;AAAA,SAAeA,CAAC,CAACC,MAAF,GAAW,CAA1B;AAAA,CAAtB;AAEP,OAAO,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAAIC,GAAJ;AAAA,SAAsCA,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAKC,SAA9D;AAAA,CAAlB;AAEP,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACC,GAAD,EAAyB;AACjD,MAAMC,SAAoC,GAAG;AAC3C,SAAK,OADsC;AAE3C,SAAK,MAFsC;AAG3C,SAAK,MAHsC;AAI3C,SAAK,QAJsC;AAK3C,SAAK,OALsC;AAM3C,SAAK;AANsC,GAA7C;AASA,SAAOC,MAAM,CAACF,GAAD,CAAN,CAAYG,OAAZ,CAAoB,WAApB,EAAiC,UAASC,CAAT,EAAY;AAClD,WAAOH,SAAS,CAACG,CAAD,CAAhB;AACD,GAFM,CAAP;AAGD,CAbM;AAeP,OAAO,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,CAACC,MAAD,EAAuC;AACvE,MAAIA,MAAM,KAAK,IAAf,EAAqB;AACnB,WAAO,QAAP;AACD;;AACD,MAAIC,MAAM,GAAG,CAACD,MAAM,CAACE,QAAP,IAAmB,EAApB,IAA0B,GAAvC;AACA,MAAMC,YAAsB,GAAG,EAA/B;;AACA,OAAK,IAAMC,KAAX,IAAoBJ,MAApB,EAA4B;AAC1B,QAAII,KAAK,KAAK,UAAd,EAA0B;AACxBD,MAAAA,YAAY,CAACE,IAAb,CAAkBD,KAAK,GAAG,IAAR,GAAeJ,MAAM,CAACI,KAAD,CAArB,GAA+B,GAAjD;AACD;AACF;;AACDH,EAAAA,MAAM,IAAIE,YAAY,CAACG,IAAb,CAAkB,IAAlB,IAA0B,GAApC;AACA,SAAOL,MAAP;AACD,CAbM;AAeP,OAAO,IAAMM,aAAa,GAAG,SAAhBA,aAAgB,CAACC,WAAD,EAAwC;AACnE,MAAIA,WAAW,KAAK,EAApB,EAAwB;AACtB,WAAO,IAAP;AACD;;AACD,MAAIA,WAAW,KAAK,GAApB,EAAyB;AACvB;AACA,WAAO,CAAP;AACD;;AAED,MAAMC,UAAU,GAAG,IAAIC,MAAJ,CAAW,yFAAX,CAAnB;AACA,MAAMC,OAAO,GAAGH,WAAW,CAACI,KAAZ,CAAkBH,UAAlB,CAAhB;;AACA,MAAI,CAACE,OAAL,EAAc;AACZ,WAAO,IAAP;AACD;;AAED,MAAIE,GAAG,GAAG,CAAV,CAfmE,CAiBnE;AACA;;AACA,MAAMC,CAAC,GAAG,SAAJA,CAAI,CAACC,GAAD,EAAcC,IAAd,EAA+B;AACvC,QAAIL,OAAO,CAACI,GAAD,CAAP,KAAiBvB,SAArB,EAAgC;AAC9B;AACD;;AACD,QAAMyB,CAAC,GAAGC,QAAQ,CAACP,OAAO,CAACI,GAAD,CAAR,CAAlB;AACAF,IAAAA,GAAG,IAAII,CAAC,GAAGD,IAAX;AACD,GAND;;AAQAF,EAAAA,CAAC,CAAC,CAAD,EAAI,OAAO,EAAP,GAAY,EAAZ,GAAiB,EAAjB,GAAsB,GAA1B,CAAD,CA3BmE,CA2BlC;;AACjCA,EAAAA,CAAC,CAAC,CAAD,EAAI,OAAO,EAAP,GAAY,EAAZ,GAAiB,EAAjB,GAAsB,CAA1B,CAAD,CA5BmE,CA4BpC;;AAC/BA,EAAAA,CAAC,CAAC,CAAD,EAAI,OAAO,EAAP,GAAY,EAAZ,GAAiB,EAArB,CAAD,CA7BmE,CA6BxC;;AAC3BA,EAAAA,CAAC,CAAC,CAAD,EAAI,OAAO,EAAP,GAAY,EAAhB,CAAD,CA9BmE,CA8B7C;;AACtBA,EAAAA,CAAC,CAAC,EAAD,EAAK,OAAO,EAAZ,CAAD,CA/BmE,CA+BjD;;AAClBA,EAAAA,CAAC,CAAC,EAAD,EAAK,IAAL,CAAD,CAhCmE,CAgCtD;;AACbA,EAAAA,CAAC,CAAC,EAAD,EAAK,CAAL,CAAD,CAjCmE,CAiCzD;;AAEV,SAAOD,GAAP;AACD,CApCM;AAsCP,OAAO,IAAMM,cAAc,GAAG,SAAjBA,cAAiB,CAACC,CAAD,EAAuB;AACnD,MAAIC,EAAE,GAAGD,CAAT;AACA,MAAIE,CAAC,GAAG,EAAR;;AACA,MAAID,EAAE,KAAK,CAAX,EAAc;AACZ,WAAO,IAAP;AACD;;AAED,MAAME,CAAC,GAAG,SAAJA,CAAI,CAACC,IAAD,EAAeR,IAAf,EAA6BS,KAA7B,EAAgD;AACxD,QAAIA,KAAK,IAAIJ,EAAE,GAAGL,IAAL,KAAc,CAA3B,EAA8B;AAC5B;AACD;;AACD,QAAMU,CAAC,GAAG3C,IAAI,CAAC4C,KAAL,CAAWN,EAAE,GAAGL,IAAhB,CAAV;;AACA,QAAIU,CAAC,GAAG,CAAR,EAAW;AACTJ,MAAAA,CAAC,cAAOI,CAAP,SAAWF,IAAX,CAAD;AACAH,MAAAA,EAAE,IAAIK,CAAC,GAAGV,IAAV;AACD;AACF,GATD,CAPmD,CAkBnD;AACA;;;AACAO,EAAAA,CAAC,CAAC,GAAD,EAAM,OAAO,EAAP,GAAY,EAAZ,GAAiB,EAAjB,GAAsB,GAA5B,EAAiC,IAAjC,CAAD;AACAA,EAAAA,CAAC,CAAC,GAAD,EAAM,OAAO,EAAP,GAAY,EAAZ,GAAiB,EAAjB,GAAsB,CAA5B,EAA+B,IAA/B,CAAD;AAEAA,EAAAA,CAAC,CAAC,GAAD,EAAM,OAAO,EAAP,GAAY,EAAZ,GAAiB,EAAvB,EAA2B,KAA3B,CAAD;AACAA,EAAAA,CAAC,CAAC,GAAD,EAAM,OAAO,EAAP,GAAY,EAAlB,EAAsB,KAAtB,CAAD;AACAA,EAAAA,CAAC,CAAC,GAAD,EAAM,OAAO,EAAb,EAAiB,KAAjB,CAAD;AACAA,EAAAA,CAAC,CAAC,GAAD,EAAM,IAAN,EAAY,KAAZ,CAAD;AACAA,EAAAA,CAAC,CAAC,IAAD,EAAO,CAAP,EAAU,KAAV,CAAD;AAEA,SAAOD,CAAP;AACD,CA9BM;AAgCP,OAAO,SAASM,SAAT,CAAmBC,QAAnB,EAA6C;AAClD,SAAOlD,MAAM,CAACmD,GAAP,CAAWD,QAAX,EAAqBE,OAArB,EAAP;AACD;AAED,OAAO,SAASC,UAAT,CAAoBC,IAApB,EAA0C;AAC/C,SAAOtD,MAAM,CAACmD,GAAP,CAAWG,IAAX,EAAiBC,MAAjB,CAAwB,qBAAxB,CAAP;AACD;AAED,OAAO,IAAMC,GAAG,GAAG,SAANA,GAAM;AAAA,SAAcxD,MAAM,GAAGoD,OAAT,EAAd;AAAA,CAAZ;AAEP,OAAO,IAAMK,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACC,YAAD,EAAkC;AAChE,MAAMC,IAAI,GAAGD,YAAY,GAAG,CAAf,GAAmB,GAAnB,GAAyB,EAAtC;AACA,MAAME,cAAc,GAAGF,YAAY,GAAG,CAAf,GAAmB,CAAC,CAAD,GAAKA,YAAxB,GAAuCA,YAA9D;AACA,MAAMG,QAAQ,GAAG7D,MAAM,CAAC6D,QAAP,CAAgBD,cAAhB,EAAgC,IAAhC,CAAjB;AACA,MAAMlB,EAAE,GAAGtC,IAAI,CAAC4C,KAAL,CAAWa,QAAQ,CAACH,YAAT,EAAX,CAAX;AACA,MAAMvC,CAAC,GAAGf,IAAI,CAAC4C,KAAL,CAAWa,QAAQ,CAACC,OAAT,EAAX,CAAV;AACA,MAAM3B,CAAC,GAAG/B,IAAI,CAAC4C,KAAL,CAAWa,QAAQ,CAACE,OAAT,EAAX,CAAV;AACA,MAAMC,CAAC,GAAG5D,IAAI,CAAC4C,KAAL,CAAWa,QAAQ,CAACI,KAAT,EAAX,CAAV;AACA,MAAMxB,CAAC,GAAGrC,IAAI,CAAC4C,KAAL,CAAWa,QAAQ,CAACK,MAAT,EAAX,CAAV;;AACA,MAAIzB,CAAC,KAAK,CAAV,EAAa;AACX,qBAAUkB,IAAV,SAAiBlB,CAAjB,eAAuBuB,CAAvB,eAA6B7B,CAA7B,eAAmChB,CAAnC;AACD;;AACD,MAAI6C,CAAC,KAAK,CAAV,EAAa;AACX,qBAAUL,IAAV,SAAiBK,CAAjB,eAAuB7B,CAAvB,eAA6BhB,CAA7B;AACD;;AACD,MAAIgB,CAAC,KAAK,CAAV,EAAa;AACX,qBAAUwB,IAAV,SAAiBxB,CAAjB,eAAuBhB,CAAvB;AACD;;AACD,MAAIA,CAAC,KAAK,CAAV,EAAa;AACX,qBAAUwC,IAAV,SAAiBxC,CAAjB,cAAsBuB,EAAtB;AACD;;AACD,MAAIkB,cAAc,GAAG,CAArB,EAAwB;AACtB,qBAAUD,IAAV,SAAiBC,cAAc,CAACO,OAAf,CAAuB,CAAvB,CAAjB;AACD;;AACD,SAAO,IAAP;AACD,CAzBM;AA2BP,OAAO,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAACC,QAAD,EAAmBC,GAAnB,EAA2C;AACvE,MAAMC,KAAK,GAAGtB,SAAS,CAACoB,QAAD,CAAvB;;AACA,MAAIE,KAAK,GAAG,CAAZ,EAAe;AACb,WAAO,OAAP;AACD;;AACD,SAAOd,gBAAgB,CAACa,GAAG,GAAGC,KAAP,CAAvB;AACD,CANM;AAQP,IAAMC,WAAW,GAAG,eAApB;AAEA,OAAO,IAAMC,iCAAiC,GAAG,SAApCA,iCAAoC,CAACC,KAAD,EAAgC;AAC/E,MAAIA,KAAK,KAAK,EAAd,EAAkB;AAChB,WAAO,EAAP;AACD;;AACD,MAAMC,SAAS,GAAGD,KAAK,CAACE,SAAN,CAAgB,CAAhB,EAAmBC,KAAnB,CAAyB,GAAzB,CAAlB;AAEA,SAAOF,SAAS,CAACG,MAAV,CAA8B,UAACC,MAAD,EAASC,QAAT,EAAmBC,CAAnB,EAAyB;AAC5D,QAAMC,WAAW,GAAGH,MAAM,CAACrE,MAA3B;AACA,QAAMyE,MAAM,cAAOD,WAAP,MAAZ;;AACA,QAAIF,QAAQ,CAACI,UAAT,WAAuBD,MAAvB,WAAJ,EAA2C;AACzC,UAAME,SAAS,GAAGF,MAAM,CAACzE,MAAzB;AACA,0CACKqE,MADL,IAEE;AACEO,QAAAA,EAAE,EAAEnF,UAAU,EADhB;AAEEoF,QAAAA,GAAG,YAAKL,WAAL,CAFL;AAGEM,QAAAA,OAAO,EAAEb,SAAS,CAACc,KAAV,CAAgBR,CAAhB,EAAmBH,MAAnB,CAA0B,UAACY,IAAD,EAAOC,KAAP,EAAiB;AAClD,iBAAOA,KAAK,CAACP,UAAN,CAAiBD,MAAjB,KAA4BX,WAAW,CAACoB,IAAZ,CAAiBD,KAAjB,CAA5B,mCACED,IADF,GACWG,WAAW,CAACF,KAAK,CAACf,SAAN,CAAgBS,SAAhB,CAAD,CADtB,IAEHK,IAFJ;AAGD,SAJQ,EAINxF,mBAJM;AAHX,OAFF;AAYD;;AACD,WAAO6E,MAAP;AACD,GAnBM,EAmBJ,EAnBI,CAAP;AAoBD,CA1BM;AA4BP,OAAO,IAAMc,WAAW,GAAG,SAAdA,WAAc,CAACF,KAAD,EAA0C;AAAA,qBAChDA,KAAK,CAACd,KAAN,CAAY,GAAZ,CADgD;AAAA;AAAA,MAC5DiB,GAD4D;AAAA,MACvDC,GADuD;;AAEnE,MAAMC,YAAY,GAAGC,kBAAkB,CAACF,GAAG,CAAC7E,OAAJ,CAAY,KAAZ,EAAmB,GAAnB,CAAD,CAAvC;;AACA,UAAQ4E,GAAR;AACE,SAAK,MAAL;AACE,aAAO;AAAEI,QAAAA,IAAI,EAAEF;AAAR,OAAP;;AAEF,SAAK,KAAL;AACE,aAAO;AAAEG,QAAAA,IAAI,EAAEH,YAAY,KAAK,GAAjB,GAAuB/F,SAAS,CAACmG,KAAjC,GAAyCnG,SAAS,CAACoG;AAA3D,OAAP;;AAEF,SAAK,SAAL;AACE,aAAO;AAAEC,QAAAA,OAAO,EAAEN,YAAY,KAAK;AAA5B,OAAP;;AAEF,SAAK,aAAL;AACE,UAAMO,KAAK,GAAG3E,aAAa,CAACoE,YAAD,CAA3B;AACA,aAAOrF,SAAS,CAAC4F,KAAD,CAAT,GAAmB;AAAEA,QAAAA;AAAF,OAAnB,GAA+B,EAAtC;;AAEF,SAAK,WAAL;AACA,SAAK,cAAL;AACE,aAAO;AAAEC,QAAAA,OAAO,EAAEvD,SAAS,CAAC+C,YAAD;AAApB,OAAP;;AAEF,SAAK,YAAL;AACE,UAAMS,UAAU,GAAGlE,QAAQ,CAACyD,YAAD,CAA3B;AACA,aAAOS,UAAU,GAAG,CAAb,GAAiB;AAAEA,QAAAA;AAAF,OAAjB,GAAkC,EAAzC;AApBJ;;AAsBA,SAAO,EAAP;AACD,CA1BM;AA4BP,OAAO,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAACnB,GAAD;AAAA,SAAiB,UAACoB,SAAD,EAAoBC,KAApB,EAAyD;AACnG,sBAAWrB,GAAX,cAAkBoB,SAAlB,cAA+BE,kBAAkB,CAACD,KAAD,CAAjD;AACD,GAF0B;AAAA,CAApB;AAIP,OAAO,IAAME,aAAa,GAAG,SAAhBA,aAAgB,OAAiC;AAAA,MAA9BvB,GAA8B,QAA9BA,GAA8B;AAAA,MAAzBC,OAAyB,QAAzBA,OAAyB;AAC5D,MAAMuB,aAAa,GAAGL,WAAW,CAACnB,GAAD,CAAjC;AAD4D,MAEpDW,IAFoD,GAEAV,OAFA,CAEpDU,IAFoD;AAAA,MAE9CC,IAF8C,GAEAX,OAFA,CAE9CW,IAF8C;AAAA,MAExCG,OAFwC,GAEAd,OAFA,CAExCc,OAFwC;AAAA,MAE/BC,KAF+B,GAEAf,OAFA,CAE/Be,KAF+B;AAAA,MAExBC,OAFwB,GAEAhB,OAFA,CAExBgB,OAFwB;AAAA,MAEfC,UAFe,GAEAjB,OAFA,CAEfiB,UAFe;AAG5D,MAAMnD,IAAI,GAAG3C,SAAS,CAAC6F,OAAD,CAAT,GAAqBnD,UAAU,CAACmD,OAAD,CAA/B,GAA2C,KAAxD;AACA,MAAM7B,SAAS,GAAG,CAChBoC,aAAa,CAAC,MAAD,EAASb,IAAT,CADG,EAEhBa,aAAa,CAAC,KAAD,EAAQZ,IAAI,KAAKlG,SAAS,CAACmG,KAAnB,GAA2B,CAA3B,GAA+B,CAAvC,CAFG,EAGhBW,aAAa,CAAC,SAAD,EAAYT,OAAO,GAAG,CAAH,GAAO,CAA1B,CAHG,EAIhBS,aAAa,CAAC,aAAD,EAAgBvE,cAAc,CAAC+D,KAAD,CAA9B,CAJG,EAKhBjD,IAAI,aAAMyD,aAAa,CAAC,WAAD,EAAczD,IAAd,CAAnB,cAA0CyD,aAAa,CAAC,cAAD,EAAiBzD,IAAjB,CAAvD,IAAkF,EALtE,EAMhB3C,SAAS,CAAC8F,UAAD,CAAT,GAAwBM,aAAa,CAAC,YAAD,EAAeN,UAAf,CAArC,GAAkE,EANlD,CAAlB;AAQA,SAAO9B,SAAS,CAACqC,MAAV,CAAiBxG,aAAjB,EAAgCmB,IAAhC,CAAqC,GAArC,CAAP;AACD,CAbM;AAeP,OAAO,IAAMsF,+BAA+B,GAAG,SAAlCA,+BAAkC,CAAClC,MAAD,EAAyB;AACtE,oBAAWA,MAAM,CAACmC,GAAP,CAAWJ,aAAX,EAA0BnF,IAA1B,CAA+B,GAA/B,CAAX;AACD,CAFM;AAIP,OAAO,IAAMwF,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACjB,IAAD,EAAkB;AACpD,oCAA2BW,kBAAkB,CAACX,IAAD,CAA7C;AACD,CAFM;AAGP,OAAO,IAAMkB,aAAa,GAAG,SAAhBA,aAAgB,CAC3BC,CAD2B,EAE3BC,EAF2B;AAAA,SAGxBC,MAAM,CAACC,OAAP,CAAeH,CAAf,EAAkBH,GAAlB,CAAsBI,EAAtB,CAHwB;AAAA,CAAtB;AAKP,OAAO,IAAMG,OAAO,GAAG,SAAVA,OAAU;AAAA,oCAAIC,GAAJ;AAAIA,IAAAA,GAAJ;AAAA;;AAAA,SAA2C,YAAkB;AAAA,uCAAdC,IAAc;AAAdA,MAAAA,IAAc;AAAA;;AAClF;AACAD,IAAAA,GAAG,CAACV,MAAJ,CAAWY,OAAX,EAAoBC,OAApB,CAA4B,UAAAC,EAAE;AAAA,aAAIA,EAAE,CAACC,KAAH,CAAS,IAAT,EAAeJ,IAAf,CAAJ;AAAA,KAA9B;AACD,GAHsB;AAAA,CAAhB;AAKP,OAAO,IAAMK,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACpB,KAAD,EAAmB;AACrD,MAAIqB,KAAK,CAACC,MAAM,CAACtB,KAAD,CAAP,CAAT,EAA0B;AACxB,WAAOA,KAAP;AACD,GAFD,MAEO;AACL,WAAOsB,MAAM,CAACtB,KAAD,CAAb;AACD;AACF,CANM","sourcesContent":["import moment from 'moment-timezone';\n\nimport { PanelOptions, PanelType, PanelDefaultOptions } from '../pages/graph/Panel';\nimport { PanelMeta } from '../pages/graph/PanelList';\n\nexport const generateID = () => {\n  return `_${Math.random()\n    .toString(36)\n    .substr(2, 9)}`;\n};\n\nexport const byEmptyString = (p: string) => p.length > 0;\n\nexport const isPresent = <T>(obj: T): obj is NonNullable<T> => obj !== null && obj !== undefined;\n\nexport const escapeHTML = (str: string): string => {\n  const entityMap: { [key: string]: string } = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;',\n  };\n\n  return String(str).replace(/[&<>\"'/]/g, function(s) {\n    return entityMap[s];\n  });\n};\n\nexport const metricToSeriesName = (labels: { [key: string]: string }) => {\n  if (labels === null) {\n    return 'scalar';\n  }\n  let tsName = (labels.__name__ || '') + '{';\n  const labelStrings: string[] = [];\n  for (const label in labels) {\n    if (label !== '__name__') {\n      labelStrings.push(label + '=\"' + labels[label] + '\"');\n    }\n  }\n  tsName += labelStrings.join(', ') + '}';\n  return tsName;\n};\n\nexport const parseDuration = (durationStr: string): number | null => {\n  if (durationStr === '') {\n    return null;\n  }\n  if (durationStr === '0') {\n    // Allow 0 without a unit.\n    return 0;\n  }\n\n  const durationRE = new RegExp('^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$');\n  const matches = durationStr.match(durationRE);\n  if (!matches) {\n    return null;\n  }\n\n  let dur = 0;\n\n  // Parse the match at pos `pos` in the regex and use `mult` to turn that\n  // into ms, then add that value to the total parsed duration.\n  const m = (pos: number, mult: number) => {\n    if (matches[pos] === undefined) {\n      return;\n    }\n    const n = parseInt(matches[pos]);\n    dur += n * mult;\n  };\n\n  m(2, 1000 * 60 * 60 * 24 * 365); // y\n  m(4, 1000 * 60 * 60 * 24 * 7); // w\n  m(6, 1000 * 60 * 60 * 24); // d\n  m(8, 1000 * 60 * 60); // h\n  m(10, 1000 * 60); // m\n  m(12, 1000); // s\n  m(14, 1); // ms\n\n  return dur;\n};\n\nexport const formatDuration = (d: number): string => {\n  let ms = d;\n  let r = '';\n  if (ms === 0) {\n    return '0s';\n  }\n\n  const f = (unit: string, mult: number, exact: boolean) => {\n    if (exact && ms % mult !== 0) {\n      return;\n    }\n    const v = Math.floor(ms / mult);\n    if (v > 0) {\n      r += `${v}${unit}`;\n      ms -= v * mult;\n    }\n  };\n\n  // Only format years and weeks if the remainder is zero, as it is often\n  // easier to read 90d than 12w6d.\n  f('y', 1000 * 60 * 60 * 24 * 365, true);\n  f('w', 1000 * 60 * 60 * 24 * 7, true);\n\n  f('d', 1000 * 60 * 60 * 24, false);\n  f('h', 1000 * 60 * 60, false);\n  f('m', 1000 * 60, false);\n  f('s', 1000, false);\n  f('ms', 1, false);\n\n  return r;\n};\n\nexport function parseTime(timeText: string): number {\n  return moment.utc(timeText).valueOf();\n}\n\nexport function formatTime(time: number): string {\n  return moment.utc(time).format('YYYY-MM-DD HH:mm:ss');\n}\n\nexport const now = (): number => moment().valueOf();\n\nexport const humanizeDuration = (milliseconds: number): string => {\n  const sign = milliseconds < 0 ? '-' : '';\n  const unsignedMillis = milliseconds < 0 ? -1 * milliseconds : milliseconds;\n  const duration = moment.duration(unsignedMillis, 'ms');\n  const ms = Math.floor(duration.milliseconds());\n  const s = Math.floor(duration.seconds());\n  const m = Math.floor(duration.minutes());\n  const h = Math.floor(duration.hours());\n  const d = Math.floor(duration.asDays());\n  if (d !== 0) {\n    return `${sign}${d}d ${h}h ${m}m ${s}s`;\n  }\n  if (h !== 0) {\n    return `${sign}${h}h ${m}m ${s}s`;\n  }\n  if (m !== 0) {\n    return `${sign}${m}m ${s}s`;\n  }\n  if (s !== 0) {\n    return `${sign}${s}.${ms}s`;\n  }\n  if (unsignedMillis > 0) {\n    return `${sign}${unsignedMillis.toFixed(3)}ms`;\n  }\n  return '0s';\n};\n\nexport const formatRelative = (startStr: string, end: number): string => {\n  const start = parseTime(startStr);\n  if (start < 0) {\n    return 'Never';\n  }\n  return humanizeDuration(end - start);\n};\n\nconst paramFormat = /^g\\d+\\..+=.+$/;\n\nexport const decodePanelOptionsFromQueryString = (query: string): PanelMeta[] => {\n  if (query === '') {\n    return [];\n  }\n  const urlParams = query.substring(1).split('&');\n\n  return urlParams.reduce<PanelMeta[]>((panels, urlParam, i) => {\n    const panelsCount = panels.length;\n    const prefix = `g${panelsCount}.`;\n    if (urlParam.startsWith(`${prefix}expr=`)) {\n      const prefixLen = prefix.length;\n      return [\n        ...panels,\n        {\n          id: generateID(),\n          key: `${panelsCount}`,\n          options: urlParams.slice(i).reduce((opts, param) => {\n            return param.startsWith(prefix) && paramFormat.test(param)\n              ? { ...opts, ...parseOption(param.substring(prefixLen)) }\n              : opts;\n          }, PanelDefaultOptions),\n        },\n      ];\n    }\n    return panels;\n  }, []);\n};\n\nexport const parseOption = (param: string): Partial<PanelOptions> => {\n  const [opt, val] = param.split('=');\n  const decodedValue = decodeURIComponent(val.replace(/\\+/g, ' '));\n  switch (opt) {\n    case 'expr':\n      return { expr: decodedValue };\n\n    case 'tab':\n      return { type: decodedValue === '0' ? PanelType.Graph : PanelType.Table };\n\n    case 'stacked':\n      return { stacked: decodedValue === '1' };\n\n    case 'range_input':\n      const range = parseDuration(decodedValue);\n      return isPresent(range) ? { range } : {};\n\n    case 'end_input':\n    case 'moment_input':\n      return { endTime: parseTime(decodedValue) };\n\n    case 'step_input':\n      const resolution = parseInt(decodedValue);\n      return resolution > 0 ? { resolution } : {};\n  }\n  return {};\n};\n\nexport const formatParam = (key: string) => (paramName: string, value: number | string | boolean) => {\n  return `g${key}.${paramName}=${encodeURIComponent(value)}`;\n};\n\nexport const toQueryString = ({ key, options }: PanelMeta) => {\n  const formatWithKey = formatParam(key);\n  const { expr, type, stacked, range, endTime, resolution } = options;\n  const time = isPresent(endTime) ? formatTime(endTime) : false;\n  const urlParams = [\n    formatWithKey('expr', expr),\n    formatWithKey('tab', type === PanelType.Graph ? 0 : 1),\n    formatWithKey('stacked', stacked ? 1 : 0),\n    formatWithKey('range_input', formatDuration(range)),\n    time ? `${formatWithKey('end_input', time)}&${formatWithKey('moment_input', time)}` : '',\n    isPresent(resolution) ? formatWithKey('step_input', resolution) : '',\n  ];\n  return urlParams.filter(byEmptyString).join('&');\n};\n\nexport const encodePanelOptionsToQueryString = (panels: PanelMeta[]) => {\n  return `?${panels.map(toQueryString).join('&')}`;\n};\n\nexport const createExpressionLink = (expr: string) => {\n  return `../graph?g0.expr=${encodeURIComponent(expr)}&g0.tab=1&g0.stacked=0&g0.range_input=1h`;\n};\nexport const mapObjEntries = <T, key extends keyof T, Z>(\n  o: T,\n  cb: ([k, v]: [string, T[key]], i: number, arr: [string, T[key]][]) => Z\n) => Object.entries(o).map(cb);\n\nexport const callAll = (...fns: Array<(...args: any) => void>) => (...args: any) => {\n  // eslint-disable-next-line prefer-spread\n  fns.filter(Boolean).forEach(fn => fn.apply(null, args));\n};\n\nexport const parsePrometheusFloat = (value: string) => {\n  if (isNaN(Number(value))) {\n    return value;\n  } else {\n    return Number(value);\n  }\n};\n"]},"metadata":{},"sourceType":"module"}